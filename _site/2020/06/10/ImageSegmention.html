<!DOCTYPE html>
<html>

<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
<meta charset="utf-8" />
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
<title>Khoa học dữ liệu</title>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<!-- Style for main home page -->
<link rel="stylesheet" href="/assets/css/styles.css">
<link rel="stylesheet" href="/assets/css/styles_toc.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> 
<link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300" rel="stylesheet">
<!-- <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> -->
<link href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Fira+Sans" rel="stylesheet">
<link rel="icon" type="image/jpg" href="assets/images/logo.jpg" sizes="32x32">
<link rel="canonical" href="https://phamdinhkhanh.github.io"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="author" content="Phạm Đình Khánh" />
<meta property="og:title" content="" />
<meta property="og:site_name" content="Khanh's blog" />
<meta property="og:url" content="https://phamdinhkhanh.github.io" />
<meta property="og:description" content="" />

<meta property="og:type" content="article" />
<meta property="article:published_time" content="" />


<meta property="article:author" content="Khanh" />
<meta property="article:section" content="" />

<link rel="alternate" type="application/atom+xml" title="Khanh's blog - Atom feed" href="/feed.xml" />
<style>
	
</style>
<!-- -- Import latext  -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
	skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
	inlineMath: [['$','$']]
  }
});
</script>

<!-- Google Analytics -->

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-89509207-1', 'auto');
// ga('send', 'pageview');
ga('send', 'pageview', {
'page': '/',
'title': ''
});
</script>


<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KTCD8BX');</script>
<!-- End Google Tag Manager -->
</head>
<style>
body {
  padding: 0 7.5%;
}
</style>

<body>
	<div id="fb-root"></div>
	<!-- <script>(function(d, s, id) { -->
	  <!-- var js, fjs = d.getElementsByTagName(s)[0]; -->
	  <!-- if (d.getElementById(id)) return; -->
	  <!-- js = d.createElement(s); js.id = id; -->
	  <!-- js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.9"; -->
	  <!-- fjs.parentNode.insertBefore(js, fjs); -->
	<!-- }(document, 'script', 'facebook-jssdk'));</script> -->
	<br>
	<div content = "container">
		<div class="row">
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/img.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Latest</div>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/06/10/ImageSegmention.html">Bài 40 - Image Segmentation</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/06/04/PhoBERT_Fairseq.html">Bài 39 - Thực hành ứng dụng BERT</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/31/CNNHistory.html">Bài 38 - Các kiến trúc CNN hiện đại</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/28/TransformerThemDauTV.html">Bài 37 - Transformer thêm dấu Tiếng Việt</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/23/BERTModel.html">Bài 36 - BERT model</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/05/MultitaskLearning_MultiBranch.html">Bài 35 - Multitask Learning - Multi Branch</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/22/MultitaskLearning.html">Bài 34 - Multitask Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/15/TransferLearning.html">Bài 33 - Phương pháp Transfer Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/09/TensorflowDataset.html">Bài 32 - Kĩ thuật tensorflow Dataset</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/03/AWS.html">Bài 31 - Amazon Virtual Machine Deep Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/28/deployTensorflowJS.html">Bài 30 - Xây dựng Web AI trên tensorflow js</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/23/FlaskRestAPI.html">Bài 29 - Xây dựng Flask API cho mô hình deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/21/faceNet.html">Bài 28 - Thực hành training Facenet</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/12/faceNetAlgorithm.html">Bài 27 - Mô hình Facenet trong face recognition</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/10/DarknetGoogleColab.html">Bài 26 - Huấn luyện YOLO darknet trên google colab</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/09/DarknetAlgorithm.html">Bài 25 - YOLO You Only Look Once</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/17/ImbalancedData.html">Bài 24 - Mất cân bằng dữ liệu (imbalanced dataset)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/11/NARSyscom2015.html">Bài 23 - Neural Attentive Session-Based Recommendation</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/17/ScoreCard.html">Bài 22 - Scorecard model</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/06/ImagePreprocessing.html">Bài 21 - Tiền xử lý ảnh OpenCV</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/26/Sorfmax_Recommendation_Neural_Network.html">Bài 20 - Recommendation Neural Network</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/12/ARIMAmodel.html">Bài 19 - Mô hình ARIMA trong time series</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/02/DeepLearningLayer.html">Bài 18 - Các layers quan trọng trong deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/22/HOG.html">Bài 17 - Thuật toán HOG (Histrogram of oriented gradient)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/08/RFMModel.html">Bài 16 - Model RFM phân khúc khách hàng</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/04/Recommendation_Compound_Part1.html">Bài 15 - collaborative và content-based filtering</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/22/googleHeatmap.html">Bài 14 - Biểu đồ trên Google Map</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/05/SSDModelObjectDetection.html">Bài 13 - Model SSD trong Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/29/OverviewObjectDetection.html">Bài 12 - Các thuật toán Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/16/VisualizationPython.html">Bài 11 - Visualization trong python</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/08/LDATopicModel.html">Bài 10 - Thuật toán LDA - Xác định Topic</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/25/PyTorch_Torchtext_Tutorial.html">Bài 9 - Pytorch - Buổi 3 - torchtext module NLP</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/22/convolutional-neural-network.html">Bài 8 - Convolutional Neural Network</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/19/CorrectSpellingVietnamseTonePrediction.html">Bài 7 - Pytorch - Buổi 2 - Seq2seq model correct spelling</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/10/PytorchTurtorial1.html">Bài 6 - Pytorch - Buổi 1 - Làm quen với pytorch</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/07/15/PySparkSQL.html">Bài 5 - Model Pipeline - SparkSQL</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/06/18/AttentionLayer.html">Bài 4 -  Attention is all you need</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/05/10/Hypothesis_Statistic.html">Apenddix 1 - Lý thuyết phân phối và kiểm định thống kê</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/29/ModelWord2Vec.html">Bài 3 - Mô hình Word2Vec</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/22/Ly_thuyet_ve_mang_LSTM.html">Bài 2 - Lý thuyết về mạng LSTM part 2</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/01/07/Ky_thuat_feature_engineering.html">Bài 1 - Kĩ thuật feature engineering</a></li>
					
				</nav>
			</div>
			<div class="col-md-8 col-xs-12" style="z-index:1">
				<nav class="navbar navbar-inverse" style="background-color: #046897">
					<div class = "container-fluid">
						<div class = "navbar-header>
							<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
							</button>
							<a class="navbar-brand" href="/">
								<span style="color:#FFF">Khoa học dữ liệu - Khanh's blog</span>
							</a>
						</div>
						<br>
						<br>
						<div class="collapse navbar-collapse navbar-right" id="myNavbar">
							<ul class="nav navbar-nav">
								<li><a href="/home"><span style="color: #fff"> Home</span></a></li>
								<li><a href="/about"><span style="color: #fff"> About</span></a></li>
								<!-- <li><a href="/da"><span style="color: #fff">Data Analytics</span></a></li> -->
								<!-- <li><a href="/cv"><span style="color: #fff">Computer Vision</span></a></li> -->
								<!-- <li><a href="/nlp"><span style="color: #fff">NLP</span></a></li> -->
								<!-- <li><a href="/code"><span style="color: #fff">Code</span></a></li> -->
								<li><a href="/book"><span style="color: #fff">Book</span></a></li>
							</ul>
						</div>
					</div>
				</nav>
				<div class="PageNavigation">
				</div>
				<h1 itemprop="name" class="post-title"></h1>
				<div id="bootstrap-overrides">
					<div>
<h2><p class="post-link" style="text-align: left; color: #204081; font-weight: bold">Bài 40 - Image Segmentation</p></h2> 
<strong>10 Jun 2020 - phamdinhkhanh</strong>
</div>
<br/>
<div id="toc"></div>
<h2 id="1-khái-quát-các-bài-toán-trong-computer-vision">1. Khái quát các bài toán trong Computer Vision</h2>

<h3 id="11-các-dạng-bài-toán-trong-computer-vision">1.1. Các dạng bài toán trong Computer Vision</h3>

<p><strong>Các bài toán và ứng dụng của computer vision</strong></p>

<p><img src="https://imgur.com/M9Jjaow.png" class="largepic" /></p>

<p><strong>Hình 1</strong>: Sơ đồ các tác vụ của computer vision trong AI.</p>

<p>Các bài toán trong computer vision khá đa dạng. Image classification là lớp bài toán phổ biến nhất giúp chúng ta phân loại ảnh. Object detection thì không chỉ phân loại ảnh mà còn xác định vị trí của vật thể trong ảnh. Image Captioning kết hợp giữa ảnh và NLP để đưa ra một câu chú thích có nội dung phù hợp với bức ảnh. Nếu bạn là người yêu thích các ứng dụng của ảnh như chuyển nam thành nữ, nữ thành nam, chuyển da màu thành da đen, chuyển ảnh thành tranh vẽ thì lớp bài toán Image2Image có lẽ tìm hiểu lớp bài toán Image-to-Image Translation sẽ rất phù hợp. Những bài toán liên quan đến mặt người như Face Detection và Face Recognition là những bài toán có ứng dụng cao dùng trong quản lý doanh nghiệp sẽ rất phù hợp. Các hệ thống search, hệ thống thương mại điện tử thì sẽ cần các bài toán về search ảnh như Image Search, Image Retrieval,… Để thiết kế được những hệ thống hiểu sâu về nội dung bức ảnh hơn là object detection và object classification thì ta sẽ cần tới các thuật toán Image Segmentation. OCR là lớp bài toán nhận diện chữ quang học, đóng vai trò rất lớn trong việc số hóa văn bản và tài liệu.</p>

<p>Dựa trên những hiểu biết còn hạn chế của mình thì các bạn đã hình dung được ứng dụng của computer vision rồi chứ? Sơ đồ trên có lẽ sẽ còn phải cập nhật thường xuyên hơn nữa vì khi một nhu cầu mới phát sinh thì AI lại sản sinh ra những lớp bài toán mới và luôn phát triển chứ không ngừng nghỉ.</p>

<p>Đằng sau những lớp bài toán trên là một câu chuyện dài của các nhà khoa học trong tiến trình khai phá học máy mà đòi hỏi phải có ý tưởng về mạng và về thu thập và gãn nhãn dữ liệu.</p>

<p><strong>Tổ chức dữ liệu cho các bài toán</strong></p>

<p>Mỗi một bài toán sẽ có một cách thức thiết kế mô hình và định dạng dữ liệu input/output chuyên biệt. Chẳng hạn như lớp bài toán phổ biến nhất trong computer vision là <strong>Image Classification</strong> <a href="https://phamdinhkhanh.github.io/2019/08/22/convolutional-neural-network.html">Bài 8 - Convolutional Neural Network</a> và <a href="https://phamdinhkhanh.github.io/2020/05/31/CNNHistory.html">Bài 38 - Các kiến trúc CNN hiện đại</a> sẽ chỉ cần ảnh và nhãn của ảnh. Tuy nhiên một số bức ảnh có nhiều vật thể xuất hiện thì chúng ta vừa phải tìm nhãn cho vật thể, vừa phải khoanh vùng vị trí của vật thể trên ảnh thông qua bounding box. Do đó lớp bài toán <strong>Object Detection</strong> ở <a href="https://phamdinhkhanh.github.io/2019/09/29/OverviewObjectDetection.html">Bài 12 - Các thuật toán Object Detection</a>, <a href="https://phamdinhkhanh.github.io/2019/10/05/SSDModelObjectDetection.html">bài 13 model SSD</a>, <a href="https://phamdinhkhanh.github.io/2020/03/09/DarknetAlgorithm.html">bài 25 model YOLO</a> thì ngoài nhãn còn cần thêm tọa độ bounding box.</p>

<p>Đối với các bài toán cần phân chia ranh giới giữa các vật thể với nền và vật thể với nhau một cách rõ ràng thì Image Segmentation có sẽ sẽ phù hợp.</p>

<p>Và ở bài này chúng ta sẽ tìm hiểu thêm một lớp các bài toán trong Computer vision nữa đó là Image Segmentation.</p>

<h3 id="12-bài-toán-image-segmentation">1.2. Bài toán Image Segmentation</h3>

<p>Tên của lớp bài toán là <code class="highlighter-rouge">Image Segmentation</code> có nghĩa là <code class="highlighter-rouge">phân khúc hình ảnh</code>, hàm ý rằng bài toán sẽ phân chia một hình ảnh thành nhiều vùng ảnh khác nhau. Image Segmentation cũng có chung mục tiêu như object detection là phát hiện ra vùng ảnh chứa vật thể và gán nhãn phù hợp cho chúng. Tuy nhiên tiêu chuẩn về độ chính xác của Image Segmentation ở mức cao hơn so với Object Detection khi nó yêu cầu nhãn dự báo đúng tới từng pixel.</p>

<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/03/instance_segmentation_example.jpg" class="largepic" /></p>

<p><strong>Hình 2:</strong> Phân biệt giữa thuật toán Object Detection và Instance Segmentation. <em>Source : cs231n.stanford.edu</em></p>

<p>Mặc dù Image Segmentation yêu cầu về mức độ chi tiết cao hơn nhưng bù lại thuật toán giúp ta hiểu được nội dung của một bức ảnh ở mức độ sâu hơn khi chúng ta biết được đồng thời: <strong>Vị trí</strong> của vật thể trong ảnh, <strong>hình dạng</strong> của vật thể và <strong>từng pixel nào thuộc về vật thể nào</strong>.</p>

<h3 id="13-input-và-output-của-bài-toán-image-segmentation">1.3. Input và output của bài toán Image Segmentation</h3>

<p>Image Segmentation nếu được huấn luyện theo bài toán học có giám sát trong thị giác máy tính thì sẽ yêu cầu gán nhãn cho ảnh. Input của bài toán là một bức ảnh và output là một ma trận mask mà giá trị của từng pixel đã được gãn nhãn trên đó.</p>

<p><img src="https://imgur.com/OD9uMOE.png" class="largepic" /></p>

<p><strong>Hình 3:</strong> Input (bên trái) và Output (bên phải) của mô hình Image Segmentation đối với bài toán một đối tượng. Mỗi một nhãn segment sẽ được thể hiện bởi một màu sắc khác nhau. Màu xám là nền, màu vàng là đường viền của ảnh và màu tím là nằm bên trong vật thể.</p>

<h2 id="2-các-dạng-image-segmentation-khác-nhau">2. Các dạng image segmentation khác nhau</h2>

<p><img src="https://cdn.analyticsvidhya.com/wp-content/uploads/2019/03/Screenshot-from-2019-03-28-12-08-09.png" class="largepic" /></p>

<p>Có 2 bài toán image segmentation chính:</p>

<ul>
  <li>
    <p>Semantic segmentation: Chúng ta phân đoạn (segment) các vùng ảnh theo những nhãn khác nhau mà không phân biệt sự khác nhau giữa các đối tượng trong từng nhãn. Ví dụ trong hình ảnh bên trái chúng ta phân biệt được pixel nào thuộc về người và pixel nào thuộc về background. Tuy nhiên trong bức ảnh xuất hiện 5 người, mức độ phân chia sẽ không xác định từng pixel thuộc về người nào.</p>
  </li>
  <li>
    <p>Instance segmentation: Chúng ta phân đoạn các vùng ảnh chi tiết đến từng đối tượng trong mỗi nhãn. Ví dụ: ở hình ảnh bên phải đối với nhãn người sẽ được phân chia chi tiết tới từng người 1, 2, … , 5.</p>
  </li>
</ul>

<h2 id="3-các-ứng-dụng-của-image-segmentation">3. Các ứng dụng của Image Segmentation</h2>

<p>Image Segmentation có rất nhiều các ứng dụng trong y học, xe tự hành, xử lý ảnh vệ tinh.</p>

<ul>
  <li>Y học: Tiềm năng ứng dụng của Image Segmentation trong y học là rất lớn. Thuật toán Image Segmentation có thể hỗ trợ bác sĩ chuẩn đoán khối u từ ảnh x-quang. Ưu điểm của Image Segmentation đó là không chỉ cho chúng ta biết vị trí của các khối u trong ảnh mà còn cho chúng ta biết được hình dạng của chúng.</li>
</ul>

<p><img src="https://miro.medium.com/max/1134/1*bcOZoe2bvVadukqYw9SPHw.png" class="largepic" /></p>

<ul>
  <li>Xe tự hành: Xe tự hành đòi hỏi phải liên tục nhận thức, xử lý và lên kế hoạch trong một môi trường phát triển liên tục. Vì yêu cầu an toàn tuyệt đối và độ chính xác cao trong mọi quyết định nên một hệ thống xe tự hành cần phải xác định chính xác các vật thể xuất hiện khi tham gia giao thông như người, đèn tín hiệu, biển báo, vạch kẻ đường, xe cộ.</li>
</ul>

<p><img src="https://miro.medium.com/max/4080/1*wninXztJ90h3ZHtKXCNKFA.jpeg" class="largepic" /></p>

<ul>
  <li>Xử lý ảnh vệ tinh: Các vệ tinh quay quanh trái đất sẽ liên tục thu thập hình ảnh bề mặt trái đất ở những vùng khác nhau. Từ các bức ảnh chụp vệ tinh, mô hình <code class="highlighter-rouge">Image Segmentation</code> sẽ phân đoạn hình ảnh thành tuyến đường, khu phố, biển cả, cây cối,….</li>
</ul>

<p><img src="https://imgur.com/4zeR7Gx.png" class="largepic" /></p>

<ul>
  <li>
    <p>Ứng dụng trong nông nghiệp: Chúng ta có thể tiết kiệm được một lượng lớn thuốc trừ sâu trong nông nghiệp nhờ sử dụng hệ thống phun thuốc trừ sâu tự động có khả năng phân biệt được diện tích cỏ và cây trồng dựa trên thuật toán Image Segmentation. Khi diện tích cỏ lấn át so với cây trồng thì hệ thống sẽ tự động kích hoạt.</p>
  </li>
  <li>
    <p>Cảnh báo cháy rừng: Những hệ thống kiểm soát cháy rừng có thể segment được chính xác vị trí phát sinh các đám cháy dựa trên ảnh chụp vệ tinh. Từ đó đưa ra cảnh báo về qui mô và mức độ lây lan của các đám cháy trên diện rộng.</p>
  </li>
</ul>

<p>Và rất nhiều các tiềm năng ứng dụng của thuật toán Image Segmentation nữa đang được tiếp tục khám phá và khai thác.</p>

<h1 id="4-thuật-ngữ">4. Thuật ngữ:</h1>

<p>Trước khi tìm hiểu về các kiến trúc Image Segmentation tiêu biểu, mình sẽ giải thích một số thuật ngữ sử dụng trong bài:</p>

<ul>
  <li>
    <p><strong>Upsampling</strong>: Các kỹ thuật giúp tăng kích thước output trong mạng CNN.</p>
  </li>
  <li>
    <p><strong>Tích chập chuyển vị</strong> (Conv2DTranspose hoặc Transposed Conv2D): Một dạng tích chập giúp gia tăng kích thước của mạng CNN.</p>
  </li>
  <li>
    <p><strong>Mạng giải chập</strong> (DeconvNet hoặc Deconvolutional Neural Network): Là một mạng áp dụng liên tiếp quá trình Upsampling để giải mã ngược trở lại từ đặc trưng sang ảnh. Thường áp dụng trong các bài toán Image2Image.</p>
  </li>
  <li>
    <p><strong>Vùng nhận thức</strong> (Receptive Field): Là những vùng ảnh được áp dụng tích tập với bộ lọc để tạo ra các pixel ở output.</p>
  </li>
  <li>
    <p><strong>Ma trận dãn nở</strong> (Dilation Matrix): Là ma trận được tạo thành từ ma trận gốc bằng cách padding xen kẽ các dòng và cột bằng giá trị 0.</p>
  </li>
</ul>

<h1 id="5-mạng-giải-chập-deconvolutional-neural-network">5. Mạng giải chập (Deconvolutional Neural Network)</h1>

<p>Bạn hình dung các mạng CNN thông thường sẽ có kích thước giảm dần qua các layers để cuối cùng chúng ta thu được những đặc trưng bậc cao (high-level). Chức năng chính của CNN là chuyển từ ảnh sang đặc trưng. Vậy nếu muốn chuyển từ đặc trưng sang ảnh chúng ta sẽ cần thực hiện như thế nào?</p>

<p>Mạng giải chập sẽ giúp chúng ta thực hiện điều đó. Một mạng giải chập sẽ có kiến trúc chung là shape của các layers tăng dần. Qua từng layer mạng sẽ giải mã các khối đặc trưng thành những thông tin không gian của từng điểm ảnh và tạo thành một bức ảnh mới ở output.</p>

<p>Qúa trình gia tăng kích thước tại các layers của mạng giải chập còn được gọi là Upsampling. Trong các bài toán classification và object detection dường như là chúng ta không sử dụng mạng giải chập bởi output của những bài toán này là xác định nhãn hoặc vị trí. Thế nhưng đối với các bài toán Image2Image (đầu vào là ảnh và trả ra output cũng là ảnh), chúng ta thường xuyên bắt gặp mạng giải chập và các layer có tác dụng Upsampling như <code class="highlighter-rouge">Transposed Convolution, Dilation Convolution, Upsampling 2D</code>. Bên dưới là một số ví dụ:</p>

<p><strong>Ứng dụng trong các bài toán Image Segmentation</strong></p>

<p><img src="https://www.researchgate.net/publication/330576431/figure/fig7/AS:718439987552256@1548300849513/The-architecture-of-the-deconvolution-network-used-in-this-work-White-layers-are.png" class="largepic" /></p>

<p><strong>Hình 4</strong>: Mạng tích chập (Convolutional Neural Network) kết hợp với giải chập ( Deconvolutonal Neural Network) trong các bài toán ImageSegmentation.</p>

<p>Nhánh bên trái của một mạng Segmentation là một CNN có nhiệm vụ như một encoder để tạo đặc trưng. Nhánh bên phải làm nhiệm vụ như một decoder giúp giải mã các features sang ảnh dự báo. Như vậy decoder sẽ làm nhiệm vụ ngược lại của encoder.</p>

<p><strong>Ứng dụng của Upsampling trong GAN</strong></p>

<p>Mạng giải chập cũng thường được áp dụng trong các kiến trúc của GAN ở lớp bài toán Image2Image translation. Hãy cùng phân tích kiến trúc pix2pix Conditional GAN để hiểu hơn điều này.</p>

<p><img src="https://imgur.com/I35EOdY.png" class="largepic" /></p>

<p><strong>Hình 5</strong>: Kiến trúc pix2pix.</p>

<p>Giống như kiến trúc của một mô hình GAN thông thường, pix2pix cũng bao gồm 2 mô hình Generator và Discriminator. Mô hình Generator có tác dụng sinh ra ảnh fake gần giống với ảnh thật nhất, Discriminator sẽ làm nhiệm vụ phân loại ảnh fake và ảnh thật.</p>

<p>Quan sát kỹ hơn ở mô hình Generator bạn sẽ thấy có 2 nhánh đối lập là Encoder và Decoder. Trong đó nhánh Encoder là một mạng CNN thông thường đóng vai trò tạo đặc trưng của ảnh input. Trên nhánh Encoder kích thước output giảm đần qua các layer. Nhánh Decoder đối xứng với Encoder có tác dụng mapping từ output của Encoder sang một ảnh mới có kích thước lớn hơn nó.</p>

<p>Vậy làm cách nào ta có thể biến đổi từ một khối output có kích thước nhỏ hơn sang một khối lớn hơn? Đó là nhờ các layer Upsampling mà chúng ta sẽ cùng tìm hiểu bên dưới.</p>

<h1 id="6-upsampling-2d-layer">6. Upsampling 2D Layer</h1>

<p>Để dễ hình dung thì chức năng của Upsampling 2D layer cũng tương tự như hàm resize nhưng với kích thước lớn hơn trong opencv. Chúng ta sẽ giữ nguyên nội dung mà vẫn gia tăng được kích thước của input bằng cách copy các giá trị pixel liền kề theo các window size.</p>

<p><img src="https://imgur.com/UhwUfj0.png" class="largepic" /></p>

<p>Trên tensorflow bạn đọc có thể áp dụng UpSampling 2D thông qua layer <code class="highlighter-rouge">UpSampling2D</code> như sau:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>import tensorflow as tf
import numpy as np

input_shape = (1, 2, 2, 1)
x = np.arange(1, 5, 1).reshape(input_shape)
print('x \n', x)
upLayer = tf.keras.layers.UpSampling2D(size=(2, 2))
y = upLayer(x)
print('y: \n', y)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>x 
 [[[[1]
   [2]]

  [[3]
   [4]]]]
y: 
 tf.Tensor(
[[[[1]
   [1]
   [2]
   [2]]

  [[1]
   [1]
   [2]
   [2]]

  [[3]
   [3]
   [4]
   [4]]

  [[3]
   [3]
   [4]
   [4]]]], shape=(1, 4, 4, 1), dtype=int64)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Ngoài phương pháp upsampling bằng copy giá trị của pixel còn có những phương pháp khác như Bilinear Interpolation, Max-Unpooling, Bed of Nails. Ý tưởng của các phương pháp này khá đơn giản và bạn đọc cũng không cần ứng dụng mà không cần phải nhớ chúng.</p>

<h1 id="7-tích-chập-chuyển-vị-transposed-convolution">7. Tích chập chuyển vị (Transposed Convolution)</h1>

<p>Ngoài gia tăng kích thước thông qua Upsampling, chúng ta có thể thực hiện theo cách phức tạp hơn thông qua tích chập chuyển vị (Transposed Convolution hoặc Conv2DTranspose). Vai trò của tích chập chuyển vị xuất phát từ nhu cầu biến đổi theo quá trình ngược lại của mạng tích chập thông thường hay còn gọi là giải chập (Deconvolutional Neural Network). Gỉa sử từ ma trận đầu vào có kích thước  $(w_1,h_1)$  sau khi áp dụng phép tích chập thông thường ta thu được kích thước $(w_2,h_2)$ . Tích chập chuyển vị sẽ biến đổi từ một ma trận có kích thước $(w_2,h_2)$  của output sang ma trận có kích thước  $(w_1,h_1)$  của input trong khi vẫn duy trì được các kiểu kết nối phù hợp với tích chập. Xin trích dẫn:</p>

<p><code class="highlighter-rouge">The need for transposed convolutions generally arises from the desire to use a transformation going in the opposite direction of a normal convolution, i.e., from something that has the shape of the output of some convolution to something that has the shape of its input while maintaining a connectivity pattern that is compatible with said convolution</code></p>

<p><a href="https://arxiv.org/abs/1603.07285">A Guide To Convolution Arithmetic For Deep Learning, 2016</a>.</p>

<p>Trên thực tế thì có thể coi tích chập chuyển vị là một quá trình ngược của tích chập thông thường khi mỗi một pixel được mapping sang các đặc trưng ảnh thay vì ngược lại từ các đặc trưng sang pixel. Xin trích dẫn:</p>

<p><code class="highlighter-rouge">A deconvnet can be thought of as a convnet model that uses the same components (filtering, pooling) but in reverse, so instead of mapping pixels to features does the opposite.</code></p>

<p><a href="https://arxiv.org/abs/1311.2901">Visualizing and Understanding Convolutional Networks, 2013</a>.</p>

<p>Bạn đọc sẽ dễ dàng hình dung hơn về tích chập chuyển vị qua ví dụ minh họa bên dưới:</p>

<p><img src="https://imgur.com/VxVTcZ0.png" class="largepic" /></p>

<p><strong>Cách tính tích chập:</strong></p>

<p>Ta di chuyển các pixel của ma trận đầu vào từ trái qua phải và từ trên xuống dưới. Sau đó lấy giá trị của pixel nhân với 
ma trận bộ lọc sẽ thu được ma trận output có kích thước tương đương. Tùy vào stride qui định là bao nhiêu mà ta sẽ di chuyển kết quả của mỗi lần nhân pixel, bộ lọc sang bấy nhiêu đơn vị. Sau cùng ta tính tổng các vị trí tương ứng của các ma trận kết quả để thu được ma trận chuyển vị. Trong trường hợp stride không bằng kích thước kernel thì ma trận kết quả tích chập sẽ overlapping lên nhau. Khi đó ta sẽ cộng dồn chúng.</p>

<p><strong>Tính kích thước cho output:</strong></p>

<p>Có 3 tham số chính ảnh hưởng đến kích thước của output trong phép nhân tích chập chuyển vị bao gồm số bước nhảy $S$, kích thước bộ lọc $F$. Công thức chung được tính như sau:</p>

<script type="math/tex; mode=display">W_{out} = (W-1) \times S + F \tag{1}</script>

<p>Trong trường hợp có thêm padding $P$ vào output thì $W_{out}$ có giá trị:</p>

<script type="math/tex; mode=display">W_{out} = (W-1) \times S + F + P \tag{2}</script>

<p>Ví dụ: $W=2, S=3, P=2, F=2$ thì output có kích thước là: $W_{out} = (2-1) \times 3 + 2 + 2 = 7$</p>

<p>Từ công thức $W_{out}$ suy ngược ra $W$:</p>

<script type="math/tex; mode=display">W = \frac{W_{out}-F-P+S}{S} \tag{3}</script>

<p>Việc chứng minh các công thức trên khá dễ dàng và xin dành cho bạn đọc.</p>

<p>Trên tensorflow ta thực hiện tích chập chuyển vị như sau:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>import tensorflow as tf
import numpy as np

W=2
S=3
P=2
F=2

input_shape = (1, W, W, 1)
x = np.random.uniform(size = input_shape).astype(np.float32)
print('x: \n', x)
con2DTran = tf.keras.layers.Conv2DTranspose(filters = 1, 
                                            kernel_size=F, 
                                            strides=S, 
                                            output_padding = P,
                                            input_shape=(2, 2, 1))
y = con2DTran(x)
print('y: \n', y.shape)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>x: 
 [[[[0.5444585 ]
   [0.24255177]]

  [[0.07139957]
   [0.4786547 ]]]]
y: 
 (1, 7, 7, 1)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Một tính chất thú vị: Nếu chúng ta truyền ma trận $X$ vào một layer tích chập chuyển vị để thu được $Y = f(X)$ và tạo ra một layer tích chập $g$ có tham số như $f$ để biến đổi ngược lại từ $Y$ thì kết quả $g(Y)$ thu được có shape bằng với $X$.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>conv2D_y = tf.keras.layers.Conv2D(filters=1, kernel_size=F, strides=S)(y)
conv2D_y.shape == x.shape
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>True
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Đó là bởi kết quả của tích chập chuyển vị là quá trình biến đổi ngược lại của tích chập.</p>

<h1 id="8-tích-chập-dãn-nở-dilation-convolution">8. Tích chập dãn nở (Dilation Convolution)</h1>

<p>Tích chập dãn nở (Dilation Convolution) cũng là một phương pháp thường được áp dụng trong các mạng giải chập.</p>

<p><img src="https://imgur.com/LMM70dw.png" class="largepic" /></p>

<p><strong>Hình 6:</strong> Từ ma trận input gốc bên trái, ta padding xen kẽ các dòng và cột 0 vào ma trận input và thu được ma trận dilation (ở giữa trong hình). Phép tích chập được thực hiện trên ma trận dilation. Kích thước ma trận sau tích chập tăng từ <code class="highlighter-rouge">2x2</code> lên <code class="highlighter-rouge">4x4</code>.</p>

<p>Mỗi pixel ở ma trận output được tính theo tích <code class="highlighter-rouge">element-wise product</code> giữa vùng nhận thức (receptive field) với bộ lọc.</p>

<script type="math/tex; mode=display">o_{ij} = \sum_{\text{sum element}}(\begin{bmatrix}
1, 0 \\
0, 0
\end{bmatrix} \otimes \begin{bmatrix}
1, 1 \\
1, 1
\end{bmatrix})= \sum_{\text{sum element}}\begin{bmatrix}
1, 0 \\
0, 0
\end{bmatrix} = 1+0+0+0 = 1</script>

<p>Cách thực hiện tương tự như đối với phép tích chập CNN tại <a href="https://phamdinhkhanh.github.io/2019/08/22/convolutional-neural-network.html">Bài 8 - Convolutional Neural Network</a>.</p>

<h1 id="9-các-thuật-toán-image-segmentation">9. Các thuật toán image segmentation</h1>

<h2 id="91-các-phương-pháp-cổ-điển">9.1. Các phương pháp cổ điển.</h2>

<p>Hầu hết các phương pháp image segmentation cổ điển đều là những phương pháp học không giám sát. Chúng ta không cần phải xác định trước nhãn cho từng pixel thuộc về đối tượng nào. Do đó dẫn tới hạn chế là các giá trị segment của ảnh khá ngẫu nhiên và không định nghĩa được các nhãn cần segment.</p>

<h3 id="911-sử-dụng-bộ-lọc-binary-threshold">9.1.1. Sử dụng bộ lọc binary threshold</h3>

<p>Các vùng ảnh sẽ được chuyển về dạng đen trắng dựa trên cường độ sáng của chúng lớn hoặc nhỏ hơn một ngưỡng cố định. Cách lọc này biến đổi theo cường độ của ngưỡng lọc và thường không chuẩn xác đối với ảnh không có phân vùng màu sắc rõ ràng. Bạn đọc có thể xem thêm <a href="http://opencv-python-tutroals.readthedocs.io/en/latest/py_tutorials/py_imgproc/py_thresholding/py_thresholding.html">Opencv Image Thresholding</a></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>import cv2
import numpy as np
from PIL import Image
import requests
from io import BytesIO
import matplotlib.pyplot as plt

url = 'https://i.imgur.com/1vzDG2J.jpg'
def _downloadImage(url):
  resp = requests.get(url)
  img = np.asarray(bytearray(resp.content), dtype="uint8")
  img = cv2.imdecode(img, cv2.IMREAD_COLOR)
  return img

# Download image  
img = _downloadImage(url)
# Gray convert
img_gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

# Filter threshold according to minimum is 127
ret, th_img = cv2.threshold(img_gray, 127, 255, cv2.THRESH_BINARY)

# Visualize
fg, ax = plt.subplots(1, 2, figsize = (8, 4))
for i, image in enumerate([img_gray, th_img]):
  ax[i].imshow(image)
  if i == 0:
    ax[i].set_title('Origin Image')
  else:
    ax[i].set_title('Threshold Image')
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200610_ImageSegmentation/ImageSegmention_20_0.png" class="largepic" /></p>

<h3 id="912-k-mean-clustering">9.1.2. k-mean clustering</h3>

<p>Thuật toán k-mean clustering sẽ phân cụm cường độ của các pixels trên ảnh thành $k$ clusters. Sau đó giá trị của mỗi pixels sẽ được thay thể bởi centroids của chúng để segment hình ảnh.</p>

<p><img src="https://imgur.com/twMuk3G.png" class="largepic" /></p>

<p><strong>Hình 7</strong>: Các phân vùng của ảnh có ranh giới bị chồng lấn. Ví dụ như một phần rìa của gương mặt, vùng mắt và môi cũng bị lẫn sang màu đỏ của khăn. Nếu chúng ta muốn xác định vùng đối tượng cần segment là toàn bộ gương mặt không phân biệt mắt, môi và rìa thì thuật toán dường như không chuẩn xác.</p>

<p>Chúng ta segmentation hình ảnh bằng thuật toán k-mean clustering trên sklearn như sau:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>import cv2
import numpy as np
from PIL import Image
import requests
from io import BytesIO
import matplotlib.pyplot as plt

img = _downloadImage(url)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre></td><td class="rouge-code"><pre>from sklearn.cluster import KMeans

# Reshape X into tensor2D: (width x heigth, n_channels)
X = img.reshape((-1, 3))
# Kmeans clustering with 3 clusters
kmeans = KMeans(n_clusters=3, random_state=0).fit(X)
print('Centers found by scikit-learn:')
print(kmeans.cluster_centers_)
pred_label = kmeans.predict(X)

# Reshape pred_label
X_img = pred_label.reshape(img.shape[:2])

# Display image clustering
fg, ax = plt.subplots(1, 2, figsize = (8, 4))
for i, image in enumerate([img, X_img]):
  ax[i].imshow(image)
  if i == 0:
    ax[i].set_title('Origin Image')
  else:
    ax[i].set_title('k-Mean clustering Image')
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>Centers found by scikit-learn:
[[ 86.33225972 140.33544883 127.99777344]
 [ 43.29972249  41.67322892  54.91830723]
 [161.73683501 176.1473516  191.64734197]]
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200610_ImageSegmentation/ImageSegmention_23_1.png" class="largepic" /></p>

<p>hạn chế của k-mean clustering là tốn kém chi phí tính toán vì khi huấn luyện cần tính khoảng cách từ centroids tới toàn bộ các pixels. Khía cạnh hạn chế khác là không rõ nên chọn bao nhiêu cluster là phù hợp.</p>

<h3 id="913-expectation-maximization-clustering">9.1.3. Expectation Maximization Clustering</h3>

<p>Là phương pháp phát triển hơn của k-Mean clustering. Nó không chỉ là thuật toán clustering thông thường mà còn tìm ra <code class="highlighter-rouge">ước lượng hợp lý tối đa</code> (maximum likelihood estimator) trong các parametric models. Khi đó các clusters được biểu diễn bởi phân phối xác suất chứ không chỉ là trung bình.</p>

<p>Chúng ta segmentation hình ảnh bằng thuật toán Expectation Maximization Clustering như sau:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>from sklearn.mixture import GaussianMixture

em = GaussianMixture(n_components=3,
              covariance_type='full', max_iter=20, random_state=0).fit(X)

pred_label = em.predict(X)

# Reshape pred_label
X_img = pred_label.reshape(img.shape[:2])

# Display image clustering
fg, ax = plt.subplots(1, 2, figsize = (8, 4))
for i, image in enumerate([img, X_img]):
  ax[i].imshow(image)
  if i == 0:
    ax[i].set_title('Origin Image')
  else:
    ax[i].set_title('EM  clustering Image')
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200610_ImageSegmentation/ImageSegmention_27_1.png" class="largepic" /></p>

<h3 id="914-mean-shift-clustering">9.1.4. Mean shift Clustering</h3>

<p>k-means và Expectation Maximization yêu cầu chúng ta phải xác định trước số lượng các clusters. Sẽ rất khó xác định chính xác số lượng clusters vì nó biến động tùy theo mỗi bức ảnh hơn là một giá trị được xác định trước.</p>

<p>Mean shift clustering khắc phục được nhược điểm này khi tự động tìm ra được số lượng các cluster là hợp lý nhất cho mỗi một bức ảnh.</p>

<p>Ý tưởng của Mean shift khá đơn giản và dựa trên phân phối histogram của bức ảnh. Nếu bạn đọc chưa biết về phân phối histogram của ảnh là gì vui lòng xem lại <a href="https://phamdinhkhanh.github.io/2019/11/22/HOG.html">Bài 17 - Thuật toán HOG</a>.</p>

<p>Giải thích ngắn gọn thì phân phối histogram là một mã hóa phân phối historgram giữa độ lớn gradient theo phương gradient trên toàn bộ grid cells của ảnh. Mỗi một bức ảnh sẽ có một véc tơ historgram đặc trưng riêng.</p>

<p><strong>Thuật toán Mean Shift</strong>:</p>

<p>Bạn đọc có thể bỏ qua phần này nếu không quan tâm tới toán.</p>

<p>Cho $n$ điểm $\mathbf{x}_{i} \in \mathbb{R}^{d}$, một kernel mật độ xác suất $\hat{f}_K$ đa biến được ước lượng dựa trên một hàm <code class="highlighter-rouge">kernel đối xứng</code> $K(\mathbf{x})$ (thông thường là Gaussian hoặc Epanechnikov) theo công thức:</p>

<script type="math/tex; mode=display">\hat{f}_K = \frac{1}{nh^d}\sum_{i=1}^{n}K(\frac{\mathbf{x}-\mathbf{x}_i}{h}) \tag{1}</script>

<p>ở đây $h$ (được gọi là tham số <code class="highlighter-rouge">bandwidth</code>) xác định bán kính của kernel. <code class="highlighter-rouge">Hàm kernel đối xứng</code> (radially symetric kernel) được xác định như sau:</p>

<script type="math/tex; mode=display">K(\mathbf{x}) = c_k k (||\mathbf{x}||^2)</script>

<table>
  <tbody>
    <tr>
      <td>với $c_k$ là hằng số chuẩn hóa và $</td>
      <td> </td>
      <td>\mathbf{x}</td>
      <td> </td>
      <td>$ là norm chuẩn bậc 2 có công thức như sau:</td>
    </tr>
  </tbody>
</table>

<script type="math/tex; mode=display">||\mathbf{x}|| = \sqrt{x_1^2+x_2^2 \dots + x_d^2}</script>

<p>Ý nghĩa của công thức (1) chính là ước lượng kernel mật độ xác suất theo hàm <code class="highlighter-rouge">kernel đối xứng</code> của toàn bộ các điểm trong bán kính <code class="highlighter-rouge">bandwidth</code>. Qúa trình ước lượng kernel mật độ xác suất KDE đã được tôi giới thiệu tại <a href="https://phamdinhkhanh.github.io/2019/09/16/VisualizationPython.html#21-density-plot">Bài 11 - Visualization trong python</a>.</p>

<p><img src="https://imgur.com/UkbswZr.png" class="largepic" /></p>

<p><strong>Hình 8:</strong> Hình (a) Quá trình ước lượng KDE. Gía trị của KDE chính là $\hat{f}_K$ ở công thức (1). Hình (b) mô tả quá trình dịch chuyển tâm thông qua tối đa hóa $\hat{f}_K$. Đường dịch chuyển của tâm sẽ từ $\mathbf{x}_i^{0}$ tới $\mathbf{x}_i^{1}$,…, tới $\mathbf{x}_i^{n}$.</p>

<p><strong>Cập nhật gradient descent:</strong></p>

<p>Để đơn giản hóa tính toán gradient descent, đặt</p>

<script type="math/tex; mode=display">\mathbf{y} = ||\frac{\mathbf{x}-\mathbf{x}\_i}{h}||^{2}</script>

<p>và $g(x) = -k’(x)$. Khi đó:</p>

<script type="math/tex; mode=display">\nabla_{\mathbf{x}} \hat{f}(\mathbf{x}) = \frac{2c_{k, d}}{nh^{d+2}}[\sum_{i=1}^{n} g(\mathbf{y})\mathbf{x}_i - \sum_{i=1}^{n} g(\mathbf{y})\mathbf{x}] = \frac{2c_{k, d}}{nh^{d+2}}[\sum_{i=1}^{n} g(\mathbf{y})] \begin{bmatrix}\frac{\mathbf{x}\_i}{\sum_{i=1}^{n} g(\mathbf{y})} - \mathbf{x}
\end{bmatrix}</script>

<p>Phân tích đạo hàm ta có: Phần tử đầu tiên $\frac{2c_{k, d}}{nh^{d+2}}[\sum_{i=1}^{n} g(\mathbf{y})]$ là tỷ trọng phân phối của hàm mật độ xác suất tại điểm $\mathbf{x}$. Phần tử thứ hai $\begin{bmatrix}\frac{\mathbf{x}_i}{\sum_{i=1}^{n} g(\mathbf{y})} - \mathbf{x}
\end{bmatrix}$ được gọi là mean shift véc tơ, kí hiệu là $\mathbf{m}$ mà di chuyển theo véc tơ này sẽ giúp gia tăng tối đa mật độ xác suất.</p>

<p>Qúa trình dịch chuyển tâm cụ thể như sau:</p>

<ol>
  <li>
    <p>Tính toán véc tơ mean shift $\mathbf{x}^t_{i}$.</p>
  </li>
  <li>
    <p>Dịch chuyển vòng tròn (hoặc cửa sổ) ước lượng mật độ xác suất bằng cách dịch tâm: $\mathbf{x}^(t+1)_{i} = \mathbf{x}^t_{i} + \mathbf{m}(\mathbf{x}^t_{i})$</p>
  </li>
  <li>
    <p>Lặp lại quá trình 1 và 2 cho tới khi $\hat{f}(\mathbf{x})$ hội tụ.</p>
  </li>
</ol>

<p>Chúng ta segmentation theo thuật toán Mean shift sử dụng skimage như sau:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre>from skimage.segmentation import quickshift
from skimage.segmentation import mark_boundaries

segments_quick = quickshift(img, kernel_size=5, max_dist=10, ratio=0.5)

# Display image clustering
fg, ax = plt.subplots(1, 2, figsize = (8, 4))

ax[0].imshow(img)
ax[0].set_title('Origin Image')
ax[1].imshow(mark_boundaries(img, segments_quick))
ax[1].set_title('Mean Shift clustering Image')
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200610_ImageSegmentation/ImageSegmention_29_1.png" class="largepic" /></p>

<p>Tiếp theo chúng ta sẽ tìm hiểu tới những kiến trúc hiện đại hơn của deep learning trong bài toán Image Segmentation.</p>

<h1 id="10-thuật-toán-mask---cnn">10. Thuật toán Mask - CNN</h1>

<p><strong>Paper:</strong> <a href="https://arxiv.org/pdf/1703.06870.pdf">Mask R-CNN</a></p>

<p><strong>Author:</strong> Kaiming He, Georgia Gkioxari, Piotr Dollar, Ross Girshick - Facebook AI Research</p>

<p><strong>Code:</strong> <a href="https://github.com/multimodallearning/pytorch-mask-rcnn">pytorch-mask-rcnn</a></p>

<p>Như chúng ta đã tìm hiểu ở <a href="https://phamdinhkhanh.github.io/2019/09/29/OverviewObjectDetection.html#43-faster-r-cnn-2016">Bài 12 - Các thuật toán Object Detection</a> thì Faster R-CNN là một trong những thuật toán thuộc họ R-CNN. Mình sẽ tóm tắt lại các bước của thuật toán này một cách ngắn gọn:</p>

<p><img src="https://imgur.com/3XooVMC.png" class="largepic" /></p>

<p><strong>Hình 9:</strong> Kiến trúc của pipeline trong mạng Faster R-CNN. <a href="https://medium.com/@jonathan_hui/image-segmentation-with-mask-r-cnn-ebe6d793272">Source Jonathan-Hui</a></p>

<p>Từ hình vẽ các bạn hình dung ra toàn bộ các xử lý của Faster R-CNN rồi chứ?</p>

<ul>
  <li>
    <p>Đầu tiên một base network (hoặc backbone) là một mạng CNN có tác dụng trích trọc đặc trưng ảnh. Chúng ta sẽ truncate output của mạng CNN và chỉ lấy feature map tại layer cuối.</p>
  </li>
  <li>
    <p>Feature map tiếp tục được huấn luyện qua một mạng RPN để tìm ra các RoI (là những vùng có khả năng cao chứa vật thể).</p>
  </li>
  <li>
    <p>RoI sẽ được crop từ feature map và sử dụng RoI pooling layer để reshape và stack các RoI thành một khối cùng kích thước.</p>
  </li>
  <li>
    <p>Khối RoI tiếp tục được truyền qua các layer fully connected và tách làm 2 nhánh, một nhánh dự báo BBox (bounding box) và một nhánh dự báo nhãn.</p>
  </li>
</ul>

<p>Nguyên lý hoạt động khá đơn giản phải không các bạn? Mask R-CNN có kiến trúc kế thừa lại Faster R-CNN nhưng add thêm nhánh mask có nhiêm vụ dự báo nhãn trên từng pixel.</p>

<p><img src="https://miro.medium.com/max/2700/1*M_ZhHp8OXzWxEsfWu2e5EA.png" class="largepic" /></p>

<p><strong>Hình 10</strong>: Kiến trúc Mask R-CNN. <a href="https://medium.com/@jonathan_hui/image-segmentation-with-mask-r-cnn-ebe6d793272">Source Jonathan-Hui</a></p>

<p>Một nhánh mới được add thêm ngay sau RoI Pooling để dự đoán mask cho ảnh.</p>

<p>Kích thước của từng kernel size và layer được thể hiện cụ thể hơn trong bài báo gốc như sau:</p>

<p><img src="https://miro.medium.com/max/1400/1*lI1yfAOzQK9coppK0kLWgg.png" class="largepic" /></p>

<p><strong>Hình 11</strong>: Bên trái là mô hình Faster R-CNN mà tác giả áp dụng đối với base network là mạng ResNet và bên phải là mạng FPN. Đối với kiến trúc FPN thì ở nhánh mask tác giả Upsampling bằng một mạng giải chập để tăng kích thước từ <code class="highlighter-rouge">14x14</code> lên <code class="highlighter-rouge">28x28</code>.</p>

<h1 id="11-unet-2012">11. Unet (2012)</h1>

<p><strong>Paper:</strong> <a href="https://arxiv.org/abs/1505.04597">U-Net: Convolutional Networks for Biomedical
Image Segmentation</a></p>

<p><strong>Author:</strong> Olaf Ronneberger, Philipp Fischer, and Thomas Brox - University of Freiburg, Germany</p>

<p><strong>Code:</strong> <a href="https://github.com/zhixuhao/unet">unet - zhixuhao</a></p>

<p>Unet là một kiến trúc được phát triển bởi Olaf Ronneberger và các cộng sự phát triển nhằm phân vùng các cấu trúc nơ ron thần kinh trong não người. Kiến trúc này lần đầu áp dụng đã dành được chiến thắng trong cuộc thi <a href="http://brainiac2.mit.edu/isbi_challenge/home">EM segmentation challenge at ISBI 2012</a>. Bí kíp nào đã giúp Unet làm nên thành công trong cuộc thi này? Hãy phân tích kiến trúc của chúng:</p>

<p><img src="https://imgur.com/lKZGO0C.png" class="largepic" /></p>

<p><strong>Hình 12</strong>: Kiến trúc mô hình Unet. Mỗi một thanh chữ nhật màu xanh là một feature map đa kênh. Kích thước <code class="highlighter-rouge">width x height</code> được kí hiệu góc trái bên dưới của thanh chữ nhật và số lượng channels được kí hiệu trên đỉnh của feature map. Các thanh chữ nhật màu trắng bên nhánh phải của hình chữ U được copy từ nhánh bên trái và concatenate vào nhánh bên phải. Mỗi một mũi tên có màu sắc khác nhau tương ứng với một phép biến đổi khác nhau như chúng ta có thể thấy trong mô tả của mạng.</p>

<p>Mạng Unet bao gồm 2 nhánh đối xứng nhau hình chữ U nên được gọi là Unet.</p>

<p>Kiến trúc mạng Unet bao gồm 2 phần là <strong>phần thu hẹp (contraction)</strong> ở bên trái và <strong>phần mở rộng (expansion)</strong> ở bên phải. Mỗi phần sẽ thực hiện một nhiệm vụ riêng như sau:</p>

<ul>
  <li>
    <p>Phần thu hẹp: Làm nhiệm vụ trích lọc đặc trưng để tìm ra bối cảnh của hình ảnh. Vai trò của phần thu hẹp tương tự như một Encoder. Một mạng Deep CNN sẽ đóng vai trò trích lọc đặc trưng. Lý do nhánh được gọi là thu hẹp vì kích thước dài và rộng của các layers giảm dần. Từ input kích thước <code class="highlighter-rouge">572x572</code> chỉ còn <code class="highlighter-rouge">32x32</code>. Đồng thời độ sâu cũng tăng dần từ 3 lên 512.</p>
  </li>
  <li>
    <p>Phần mở rộng: Gồm các layer đối xứng tương ứng với các layer của nhánh thu hẹp. Quá trình Upsampling được áp dụng giúp cho kích thước layer tăng dần lên. Sau cùng ta thu được một ảnh mask đánh dấu nhãn dự báo của từng pixel.</p>
  </li>
</ul>

<p>Đặc trưng riêng trong cấu trúc của Unet đó là áp dụng kết nối tắt đối xứng giữa layer bên trái với layer bên phải.</p>

<p>Mặc dù có độ chính xác khá cao nhưng Unet có tốc độ thấp. Với kiến trúc Unet cho input <code class="highlighter-rouge">572x572</code> như bài báo gốc có tốc độ là 5 fps. Do đó nó không phù hợp để áp dụng vào các tác vụ yêu cầu realtime như xe tự hành. Tuy nhiên, Unet lại thường được sử dụng khá phổ biến trong các tác vụ không đòi hỏi realtime vì accuracy của nó cũng không tồi và kiến trúc dễ implement.</p>

<h2 id="111-khởi-tạo-kiến-trúc-mạng-unet">11.1. Khởi tạo kiến trúc mạng Unet</h2>

<p>Khởi tạo mạng Unet khá dễ dàng nếu nhận ra qui luật của chúng.</p>

<p>Chúng ta sẽ chia mạng Unet thành những block module CNN có tác dụng downsample ở phần thu hẹp và upsample ở phần mở rộng và có thể viết thành hàm để khởi tạo chúng một cách khái quát như sau:</p>

<p><strong>Hàm khởi tạo downsample cnn block</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>import tensorflow as tf

def _downsample_cnn_block(block_input, channel, is_first = False):
  if is_first:  
    conv1 = tf.keras.layers.Conv2D(filters=channel, kernel_size=3, strides=1)(block_input)
    conv2 = tf.keras.layers.Conv2D(filters=channel, kernel_size=3, strides=1)(conv1)
    return [block_input, conv1, conv2]
  else:
    maxpool = tf.keras.layers.MaxPool2D(pool_size=2)(block_input)
    conv1 = tf.keras.layers.Conv2D(filters=channel, kernel_size=3, strides=1)(maxpool)
    conv2 = tf.keras.layers.Conv2D(filters=channel, kernel_size=3, strides=1)(conv1)
    return [maxpool, conv1, conv2]

ds_block1 = _downsample_cnn_block(tf.keras.layers.Input(shape=(572, 572, 1)), channel=64, is_first = True)
ds_block2 = _downsample_cnn_block(ds_block1[-1], channel=128)
ds_block3 = _downsample_cnn_block(ds_block2[-1], channel=256)
ds_block4 = _downsample_cnn_block(ds_block3[-1], channel=512)
ds_block5 = _downsample_cnn_block(ds_block4[-1], channel=1024)
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>Hàm khởi tạo upsample cnn block</strong></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>def _upsample_cnn_block(block_input, block_counterpart, channel, is_last = False):  
  # Upsampling block
  uppool1 = tf.keras.layers.Convolution2DTranspose(channel, kernel_size=2, strides=2)(block_input)
  # Crop block counterpart
  shape_input = uppool1.shape[2]
  shape_counterpart = block_counterpart.shape[2]
  crop_size = int((shape_counterpart-shape_input)/2)
  block_counterpart_crop = tf.keras.layers.Cropping2D(cropping=((crop_size, crop_size), (crop_size, crop_size)))(block_counterpart)
  concat = tf.keras.layers.Concatenate(axis=-1)([block_counterpart_crop, uppool1])
  conv1 = tf.keras.layers.Conv2D(filters=channel, kernel_size=3, strides=1)(concat)
  conv2 = tf.keras.layers.Conv2D(filters=channel, kernel_size=3, strides=1)(conv1)
  if is_last:
    conv3 = tf.keras.layers.Conv2D(filters=2, kernel_size=3, strides=1)(conv2)
    return [concat, conv1, conv2, conv3]
  return [uppool1, concat, conv1, conv2]

us_block4 = _upsample_cnn_block(ds_block5[-1], ds_block4[-1], channel=512)
us_block3 = _upsample_cnn_block(us_block4[-1], ds_block3[-1], channel=256)
us_block2 = _upsample_cnn_block(us_block3[-1], ds_block2[-1], channel=128)
us_block1 = _upsample_cnn_block(us_block2[-1], ds_block1[-1], channel=64, is_last = True)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="k">model</span> <span class="p">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="k">Model</span><span class="p">(</span><span class="n">inputs</span> <span class="p">=</span> <span class="n">ds_block1</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">outputs</span> <span class="p">=</span> <span class="n">us_block1</span><span class="p">[-</span><span class="m">1</span><span class="p">])</span>
<span class="k">model</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre></td><td class="rouge-code"><pre>Model: "model_4"
__________________________________________________________________________________________________
Layer (type)                    Output Shape         Param #     Connected to                     
==================================================================================================
input_4 (InputLayer)            [(None, 572, 572, 1) 0                                            
__________________________________________________________________________________________________
conv2d_5 (Conv2D)               (None, 570, 570, 64) 640         input_4[0][0]                    
__________________________________________________________________________________________________
conv2d_6 (Conv2D)               (None, 568, 568, 64) 36928       conv2d_5[0][0]                   
_____________________________________________________________________________________________
...
__________________________________________________________________________________________________
conv2d_32 (Conv2D)              (None, 386, 386, 2)  1154        conv2d_31[0][0]                  
==================================================================================================
Total params: 31,031,682
Trainable params: 31,031,682
Non-trainable params: 0
__________________________________________________________________________________________________
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Sau khi khởi tạo xong model unet chúng ta có thể visualize sơ đồ các layers của mạng.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>tf.keras.utils.plot_model(model)
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200610_ImageSegmentation/ImageSegmention_39_0.png" class="largepic" /></p>

<h1 id="12-fcn-2015">12. FCN (2015)</h1>

<p><img src="http://deeplearning.net/tutorial/_images/cat_segmentation.png" class="largepic" /></p>

<p><strong>Paper</strong>: <a href="https://arxiv.org/pdf/1411.4038.pdf">Fully Convolutional Networks for Semantic Segmentation</a></p>

<p><strong>Author</strong>: Jonathan Long∗, Evan Shelhamer∗, Trevor Darrell - UC Berkeley</p>

<p><strong>Code</strong>: <a href="https://github.com/shekkizh/FCN.tensorflow">FCN.tensorflow</a></p>

<p><strong>Hình 13:</strong> Hình minh họa kiến trúc FCN áp dụng base network là mạng VGG19.</p>

<p>FCN (Fully Convolutional Network) là một kiến trúc dựa trên mạng CNN nhằm mục đích segment một hình ảnh đầu vào bằng cách dự báo nhãn cho từng pixel trên ảnh input.</p>

<p>Kiến trúc của FCN có thể khái quát thông qua hình mô tả bên dưới:</p>

<p><img src="https://imgur.com/K4jaiFe.png" class="largepic" /></p>

<p><strong>Hình 14</strong>: Kiến trúc khái quát của mạng FCN. Nguồn <a href="https://d2l.ai/chapter_computer-vision/fcn.html">DeepLearning - Chapter 13</a></p>

<p>Kiến trúc gồm 2 path có tác dụng khác nhau đó là:</p>

<ul>
  <li>
    <p>Downsampling path: Trích suất đặc trưng ngữ cảnh và nội dung của ảnh. Downsampling path là kiến trúc thu hẹp kích thước layer. Đó chính là layer CNN ở vị trí đầu tiên, thông thường là những kiến trúc CNN cơ bản như <code class="highlighter-rouge">AlexNet, VGG16, VGG19, ResNet</code> đã được Truncate Fully Connected. Output của Downsampling path là Feature Map mang giá trị thông tin về vị trí và cường độ của các pixels. Tích chập kích thước <code class="highlighter-rouge">1x1</code> được áp dụng ngay sau block CNN với số lượng bộ lọc bằng với số lượng nhãn ở output. Trong bài báo gốc tác giả huấn luyện trên bộ dữ liệu Pascal VOC với số nhãn là 21 (20 class + 1 back ground). Sở dĩ chúng ta lựa chọn số bộ lọc như vậy là để trả ra phân phối xác suất nhãn cho mỗi pixel ở output.</p>
  </li>
  <li>
    <p>Upsampling path: Khôi phục thông tin không gian của ảnh theo các segment dự báo. Chúng ta áp dụng một layer <code class="highlighter-rouge">Transposed Conv</code> để giải chập thông tin thành segmentation map.</p>
  </li>
</ul>

<p>Toàn bộ quá trình này khá đơn giản.</p>

<h2 id="121-khởi-tạo-mô-hình-fcn-trên-tensorflow">12.1. Khởi tạo Mô hình FCN trên tensorflow</h2>

<p>Load pretrain model VGG19 từ bộ dữ liệu imagenet.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre>import tensorflow as tf
# Load pretrain model
pretrain_net = tf.keras.applications.VGG19(include_top=True, weights="imagenet")

# In ra 5 layers shape cuối cùng
for layer in pretrain_net.layers[-5:]:
  print('layer {}: {}'.format(layer.output.name, layer.output.shape))

print('pretrain_net output: ', pretrain_net.output)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre></td><td class="rouge-code"><pre>Downloading data from https://storage.googleapis.com/tensorflow/keras-applications/vgg19/vgg19_weights_tf_dim_ordering_tf_kernels.h5
574717952/574710816 [==============================] - 10s 0us/step
layer block5_pool/Identity:0: (None, 7, 7, 512)
layer flatten/Identity:0: (None, 25088)
layer fc1/Identity:0: (None, 4096)
layer fc2/Identity:0: (None, 4096)
layer predictions/Identity:0: (None, 1000)
pretrain_net output:  Tensor("predictions/Identity:0", shape=(None, 1000), dtype=float32)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Khởi tạo block CNN ở downsampling path. Chúng ta sẽ bỏ qua các fully connected layers và chỉ lấy đến layer Maxpooling ở cuối cùng có kích thước <code class="highlighter-rouge">7 x 7</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>net = tf.keras.models.Model(
    inputs = pretrain_net.input,
    outputs = pretrain_net.layers[-5].output 
)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Tiếp theo ta sẽ áp dụng tích chập <code class="highlighter-rouge">1 x 1</code> để thay đổi độ sâu của khối output từ mạng CNN ở bước trên về độ sâu <code class="highlighter-rouge">21</code>.</p>

<p>Đồng thời cần áp dụng tích chập chuyển vị (Transposed Conv) để giải chập khối <code class="highlighter-rouge">7 x 7</code> về kích thước bằng với kích thước input là <code class="highlighter-rouge">224 x 224</code>. Khi đó cần lựa chọn kích thước bộ lọc như thế nào? Áp dụng công thức (1) ta có:</p>

<script type="math/tex; mode=display">W_{out} = (W-1) \times S + F</script>

<p>Thế $W = 7, W_{out} = 224, S=32$ suy ra bộ lọc có kích thước:</p>

<script type="math/tex; mode=display">F=W_{out}-W(S-1) = 224 - 7 \times (32-1)=7</script>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre><span class="n">num_classes</span><span class="p">=</span><span class="m">21</span>
<span class="n">S</span><span class="p">=</span><span class="m">32</span> 
<span class="n">F</span><span class="p">=</span><span class="m">7</span>

<span class="p">#</span> <span class="n">T</span><span class="err">í</span><span class="n">ch</span> <span class="n">ch</span><span class="err">ậ</span><span class="n">p</span> <span class="m">1</span><span class="n">x1</span> <span class="n">tr</span><span class="err">ê</span><span class="n">n</span> <span class="n">feature</span> <span class="n">map</span> <span class="n">output</span>
<span class="n">conv2D</span> <span class="p">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Conv2D</span><span class="p">(</span>
    <span class="n">num_classes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">=</span><span class="m">1</span><span class="p">)</span>

<span class="p">#</span> <span class="n">T</span><span class="err">í</span><span class="n">ch</span> <span class="n">ch</span><span class="err">ậ</span><span class="n">p</span> <span class="n">chuy</span><span class="err">ể</span><span class="n">n</span> <span class="n">v</span><span class="err">ị</span>
<span class="n">conv2DTran</span> <span class="p">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span><span class="p">.</span><span class="n">Conv2DTranspose</span><span class="p">(</span>
    <span class="n">num_classes</span><span class="p">,</span> <span class="n">kernel_size</span><span class="p">=</span><span class="n">F</span><span class="p">,</span> <span class="n">strides</span><span class="p">=</span><span class="n">S</span><span class="p">)</span>

<span class="p">#</span> <span class="n">Kh</span><span class="err">ở</span><span class="n">i</span> <span class="n">t</span><span class="err">ạ</span><span class="n">o</span> <span class="n">m</span><span class="err">ô</span> <span class="n">h</span><span class="err">ì</span><span class="n">nh</span>
<span class="k">model</span> <span class="p">=</span> <span class="n">tf</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span><span class="p">.</span><span class="n">Sequential</span><span class="p">([</span>
    <span class="n">net</span><span class="p">,</span>
    <span class="n">conv2D</span><span class="p">,</span>
    <span class="n">conv2DTran</span>
<span class="p">])</span>

<span class="k">model</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre><span class="k">Model</span><span class="p">:</span> <span class="s2">"sequential"</span>
<span class="n">_________________________________________________________________</span>
<span class="n">Layer</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span>                 <span class="n">Output</span> <span class="n">Shape</span>              <span class="n">Param</span> <span class="p">#</span>   
<span class="p">=================================================================</span>
<span class="k">model</span> <span class="p">(</span><span class="k">Model</span><span class="p">)</span>                <span class="p">(</span><span class="n">None</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">512</span><span class="p">)</span>         <span class="m">20024384</span>  
<span class="n">_________________________________________________________________</span>
<span class="n">conv2d</span> <span class="p">(</span><span class="n">Conv2D</span><span class="p">)</span>              <span class="p">(</span><span class="n">None</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">21</span><span class="p">)</span>          <span class="m">10773</span>     
<span class="n">_________________________________________________________________</span>
<span class="n">conv2d_transpose</span> <span class="p">(</span><span class="n">Conv2DTran</span> <span class="p">(</span><span class="n">None</span><span class="p">,</span> <span class="m">224</span><span class="p">,</span> <span class="m">224</span><span class="p">,</span> <span class="m">21</span><span class="p">)</span>      <span class="m">21630</span>     
<span class="p">=================================================================</span>
<span class="n">Total</span> <span class="n">params</span><span class="p">:</span> <span class="m">20</span><span class="p">,</span><span class="m">056</span><span class="p">,</span><span class="m">787</span>
<span class="n">Trainable</span> <span class="n">params</span><span class="p">:</span> <span class="m">20</span><span class="p">,</span><span class="m">056</span><span class="p">,</span><span class="m">787</span>
<span class="n">Non</span><span class="p">-</span><span class="n">trainable</span> <span class="n">params</span><span class="p">:</span> <span class="m">0</span>
<span class="n">_________________________________________________________________</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>from tensorflow.keras.utils import plot_model
plot_model(model)
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200610_ImageSegmentation/ImageSegmention_48_0.png" class="largepic" /></p>

<h2 id="13-tổng-kết">13. Tổng kết</h2>

<p>Image Segmentation là một trong những lớp bài toán có nhiều ứng dụng thực tiễn. Image Segmentation đòi hỏi mức độ chi tiết và chính xác hơn trong việc hiểu và biểu diễn nội dung của hình ảnh so với các thuật toán khác như Image Classification, Object Detection. Ở bài viết này chúng ta đã được tìm hiểu một số khái niệm mới như mạng giải chập và các tích chập đặc biệt có chức năng đặc biệt như tích chập chuyển vị, tích chập dãn nở.</p>

<p>Đồng thời chúng ta cũng làm quen với lý thuyết thuật toán, kiến trúc mô hình và thực hành xây dựng mô hình trên tensorflow của một số kiến trúc Image Segmentation cơ bản như <code class="highlighter-rouge">Mask-CNN, Unet, FCN</code>. Các mô hình trong Image Segmentation vẫn còn tiếp tục phát triển và còn rất nhiều các mô hình mà mình sẽ đề cập ở những bài tiếp theo.</p>

<h1 id="14-tài-liệu-tham-khảo">14. Tài liệu tham khảo</h1>

<ol>
  <li>
    <p><a href="https://www.analyticsvidhya.com/blog/2019/04/introduction-image-segmentation-techniques-python/">image segmentation techniques</a></p>
  </li>
  <li>
    <p><a href="http://d2l.ai/chapter_computer-vision/index.html">13. Computer Vision - Dive Into Deep Learning</a></p>
  </li>
  <li>
    <p><a href="https://towardsdatascience.com/transposed-convolution-demystified-84ca81b4baba">transposed convolution</a></p>
  </li>
  <li>
    <p><a href="http://vision.stanford.edu/teaching/cs131_fall1617/lectures/lecture13_kmeans_mean_shift_cs131_2016">lecture13 - cs131</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/@jonathan_hui/image-segmentation-with-mask-r-cnn-ebe6d793272">Mask R-CNN - jonathan hui</a></p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/1505.04597">U-Net: Convolutional Networks for Biomedical Image Segmentation</a></p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/1411.4038">Fully Convolutional Networks for Semantic Segmentation</a></p>
  </li>
  <li>
    <p><a href="https://neptune.ai/blog/image-segmentation-in-2020">Image Segmentation in 2020</a></p>
  </li>
</ol>

<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>

<script src="/js/toc.js"></script>
<script src="/js/btnTop.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
});
</script>
				</div>
			</div>
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/logo.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Khanh's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/TowardDataScience">phamdinhkhanh blog</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/3235479620010379/">phamdinhkhanh AICode forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://kaggle.com/phamdinhkhanh">phamdinhkhanh kaggle</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://rpubs.com/phamdinhkhanh">phamdinhkhanh rpub</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://github.com/phamdinhkhanh">phamdinhkhanh github</a></li>
					<br>
					<div class="header">other's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/machinelearningcoban/">machine learning cơ bản facebook</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://forum.machinelearningcoban.com/">machine learning cơ bản forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://machinelearningmastery.com">machine learning mastery</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://viblo.asia">viblosia</a></li>
					<br>
					<div class="header">Khóa học</div>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs109/">Xác suất thống kê(Probability): CS109</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs246/">Bigdata: CS246</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://cs231n.stanford.edu/">Computer vision cơ bản: CS231N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224n/">Natural Language Processing: CS224N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224w/">Khoá phân tích mạng lưới (analysis of network): CS224W</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://web.stanford.edu/class/cs20si/">Khóa học Tensorflow: CS20SI</a></li>
				</nav>
			</div>
		</div>
	</div>
	
</body>
</html>
