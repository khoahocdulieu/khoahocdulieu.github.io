<!DOCTYPE html>
<html>

<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
<meta charset="utf-8" />
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
<title>Khoa học dữ liệu</title>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<!-- Style for main home page -->
<link rel="stylesheet" href="/assets/css/styles.css">
<link rel="stylesheet" href="/assets/css/styles_toc.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> 
<link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300" rel="stylesheet">
<!-- <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> -->
<link href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Fira+Sans" rel="stylesheet">
<link rel="icon" type="image/jpg" href="assets/images/logo.jpg" sizes="32x32">
<link rel="canonical" href="https://phamdinhkhanh.github.io"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="author" content="Phạm Đình Khánh" />
<meta property="og:title" content="" />
<meta property="og:site_name" content="Khanh's blog" />
<meta property="og:url" content="https://phamdinhkhanh.github.io" />
<meta property="og:description" content="" />

<meta property="og:type" content="article" />
<meta property="article:published_time" content="" />


<meta property="article:author" content="Khanh" />
<meta property="article:section" content="" />

<link rel="alternate" type="application/atom+xml" title="Khanh's blog - Atom feed" href="/feed.xml" />
<style>
	
</style>
<!-- -- Import latext  -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
	skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
	inlineMath: [['$','$']]
  }
});
</script>

<!-- Google Analytics -->

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-89509207-1', 'auto');
// ga('send', 'pageview');
ga('send', 'pageview', {
'page': '/',
'title': ''
});
</script>


<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KTCD8BX');</script>
<!-- End Google Tag Manager -->
</head>
<style>
body {
  padding: 0 7.5%;
}
</style>

<body>
	<div id="fb-root"></div>
	<!-- <script>(function(d, s, id) { -->
	  <!-- var js, fjs = d.getElementsByTagName(s)[0]; -->
	  <!-- if (d.getElementById(id)) return; -->
	  <!-- js = d.createElement(s); js.id = id; -->
	  <!-- js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.9"; -->
	  <!-- fjs.parentNode.insertBefore(js, fjs); -->
	<!-- }(document, 'script', 'facebook-jssdk'));</script> -->
	<br>
	<div content = "container">
		<div class="row">
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/img.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Latest</div>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/08/09/ConditionalGAN.html">Bài 45 - Conditional GAN (CGAN)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/07/25/GAN_Wasserstein.html">Bài 44 - Model Wasserstein GAN (WGAN)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/07/13/GAN.html">Bài 43 - Model GAN</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/06/20/Unet.html">Bài 42 - Thực hành Unet</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/06/18/DeepLab.html">Bài 41 - DeepLab Sentiment Segmentation</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/06/10/ImageSegmention.html">Bài 40 - Image Segmentation</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/06/04/PhoBERT_Fairseq.html">Bài 39 - Thực hành ứng dụng BERT</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/31/CNNHistory.html">Bài 38 - Các kiến trúc CNN hiện đại</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/28/TransformerThemDauTV.html">Bài 37 - Transformer thêm dấu Tiếng Việt</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/23/BERTModel.html">Bài 36 - BERT model</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/05/MultitaskLearning_MultiBranch.html">Bài 35 - Multitask Learning - Multi Branch</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/22/MultitaskLearning.html">Bài 34 - Multitask Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/15/TransferLearning.html">Bài 33 - Phương pháp Transfer Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/09/TensorflowDataset.html">Bài 32 - Kĩ thuật tensorflow Dataset</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/03/AWS.html">Bài 31 - Amazon Virtual Machine Deep Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/28/deployTensorflowJS.html">Bài 30 - Xây dựng Web AI trên tensorflow js</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/23/FlaskRestAPI.html">Bài 29 - Xây dựng Flask API cho mô hình deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/21/faceNet.html">Bài 28 - Thực hành training Facenet</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/12/faceNetAlgorithm.html">Bài 27 - Mô hình Facenet trong face recognition</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/10/DarknetGoogleColab.html">Bài 26 - Huấn luyện YOLO darknet trên google colab</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/09/DarknetAlgorithm.html">Bài 25 - YOLO You Only Look Once</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/17/ImbalancedData.html">Bài 24 - Mất cân bằng dữ liệu (imbalanced dataset)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/11/NARSyscom2015.html">Bài 23 - Neural Attentive Session-Based Recommendation</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/17/ScoreCard.html">Bài 22 - Scorecard model</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/06/ImagePreprocessing.html">Bài 21 - Tiền xử lý ảnh OpenCV</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/26/Sorfmax_Recommendation_Neural_Network.html">Bài 20 - Recommendation Neural Network</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/12/ARIMAmodel.html">Bài 19 - Mô hình ARIMA trong time series</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/02/DeepLearningLayer.html">Bài 18 - Các layers quan trọng trong deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/22/HOG.html">Bài 17 - Thuật toán HOG (Histrogram of oriented gradient)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/08/RFMModel.html">Bài 16 - Model RFM phân khúc khách hàng</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/04/Recommendation_Compound_Part1.html">Bài 15 - collaborative và content-based filtering</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/22/googleHeatmap.html">Bài 14 - Biểu đồ trên Google Map</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/05/SSDModelObjectDetection.html">Bài 13 - Model SSD trong Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/29/OverviewObjectDetection.html">Bài 12 - Các thuật toán Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/16/VisualizationPython.html">Bài 11 - Visualization trong python</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/08/LDATopicModel.html">Bài 10 - Thuật toán LDA - Xác định Topic</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/25/PyTorch_Torchtext_Tutorial.html">Bài 9 - Pytorch - Buổi 3 - torchtext module NLP</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/22/convolutional-neural-network.html">Bài 8 - Convolutional Neural Network</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/19/CorrectSpellingVietnamseTonePrediction.html">Bài 7 - Pytorch - Buổi 2 - Seq2seq model correct spelling</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/10/PytorchTurtorial1.html">Bài 6 - Pytorch - Buổi 1 - Làm quen với pytorch</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/07/15/PySparkSQL.html">Bài 5 - Model Pipeline - SparkSQL</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/06/18/AttentionLayer.html">Bài 4 -  Attention is all you need</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/05/10/Hypothesis_Statistic.html">Apenddix 1 - Lý thuyết phân phối và kiểm định thống kê</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/29/ModelWord2Vec.html">Bài 3 - Mô hình Word2Vec</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/22/Ly_thuyet_ve_mang_LSTM.html">Bài 2 - Lý thuyết về mạng LSTM part 2</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/01/07/Ky_thuat_feature_engineering.html">Bài 1 - Kĩ thuật feature engineering</a></li>
					
				</nav>
			</div>
			<div class="col-md-8 col-xs-12" style="z-index:1">
				<nav class="navbar navbar-inverse" style="background-color: #046897">
					<div class = "container-fluid">
						<div class = "navbar-header>
							<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
							</button>
							<a class="navbar-brand" href="/">
								<span style="color:#FFF">Khoa học dữ liệu - Khanh's blog</span>
							</a>
						</div>
						<br>
						<br>
						<div class="collapse navbar-collapse navbar-right" id="myNavbar">
							<ul class="nav navbar-nav">
								<li><a href="/home"><span style="color: #fff"> Home</span></a></li>
								<li><a href="/about"><span style="color: #fff"> About</span></a></li>
								<!-- <li><a href="/da"><span style="color: #fff">Data Analytics</span></a></li> -->
								<!-- <li><a href="/cv"><span style="color: #fff">Computer Vision</span></a></li> -->
								<!-- <li><a href="/nlp"><span style="color: #fff">NLP</span></a></li> -->
								<!-- <li><a href="/code"><span style="color: #fff">Code</span></a></li> -->
								<li><a href="/book"><span style="color: #fff">Book</span></a></li>
							</ul>
						</div>
					</div>
				</nav>
				<div class="PageNavigation">
				</div>
				<h1 itemprop="name" class="post-title"></h1>
				<div id="bootstrap-overrides">
					<div>
<h2><p class="post-link" style="text-align: left; color: #204081; font-weight: bold">Bài 45 - Conditional GAN (CGAN)</p></h2> 
<strong>09 Aug 2020 - phamdinhkhanh</strong>
</div>
<br/>
<div id="toc"></div>
<h1 id="1-giới-thiệu-chung">1. Giới thiệu chung</h1>

<p>Ở những bài trước chúng ta đã được tìm hiểu về model <a href="https://phamdinhkhanh.github.io/2020/07/13/GAN.html">GAN</a> và huấn luyện model GAN theo phương pháp <a href="https://phamdinhkhanh.github.io/2020/07/25/GAN_Wasserstein.html">Wasserstein</a>. Những model này sẽ tìm ra mối liên hệ giữa không gian ẩn (<em>latent space</em>) với hình ảnh huấn luyện để biến đổi một véc tơ noise ngẫu nhiên trong không gian ẩn thành hình ảnh fake có chất lượng cao. Chúng ta cùng khái quát lại kiến trúc của model GAN qua hình minh họa và tóm lược bên dưới :</p>

<p><img src="https://miro.medium.com/max/700/0*eHwnn-j4Wpkdh5F8.jpeg" class="normalpic" /></p>

<ul>
  <li>
    <p>Mô hình GAN sẽ huấn luyện đồng thời cả hai model là generator $G$ và discriminator $D$. Đây là một trò chơi zero-sum game trong lý thuyết trò chơi mà $G$ và $D$ được xem như là hai người chơi đối nghịch lợi ích.</p>
  </li>
  <li>
    <p>Mô hình generator sẽ tạo ra ảnh fake chất lượng tốt nhất để đánh lừa discriminator và discriminator sẽ tìm cách phân loại ảnh real và ảnh fake.</p>
  </li>
  <li>
    <p>Hàm loss function của GAN là kết hợp giữa loss function của generator và discriminator:</p>
  </li>
</ul>

<script type="math/tex; mode=display">\min_{G} \max_{D} V(D, G) = \underbrace{\mathbb{E}_{x \sim p_{data}(x)} [\log D(x)]}_{\text{log-probability that D predict x is real}} + \underbrace{\mathbb{E}_{z \sim p_{z}(z)} [\log (1-D(G(z)))]}_{\text{log-probability D predicts G(z) is fake}} ~~~ (1)</script>

<ul>
  <li>
    <p>Trong đó mục tiêu huấn luyện của model G là nhằm tối thiểu hóa $\log(1-D(G(z))$ và mục tiêu huấn luyện của model D là tối đa hóa $\log D(x)$.</p>
  </li>
  <li>
    <p>Qúa trình huấn luyện sẽ huấn luyện đồng thời G và D.</p>
  </li>
</ul>

<p>Mô hình GAN áp dụng các kiến trúc mạng tích chập học sâu còn được gọi là DCGAN (deep convolutional GAN). Do đó để thuận tiện, từ đây mình sẽ sử dụng tên gọi DCGAN thay cho GAN. Nhược điểm của mô hình DCGAN đó là chúng ta không thể kiểm soát được bức ảnh được sinh ra thuộc class nào. Định dạng ảnh hoàn toàn phụ thuộc vào mối quan hệ tiềm ẩn được định nghĩa trong phép ánh xạ từ véc tơ noise sang ảnh fake của generator.</p>

<p>Trên thực tế  việc kiểm soát định dạng của ảnh fake là một nhu cầu cần thiết để tạo ra những bức ảnh theo ý muốn. Do đó mô hình CGAN (conditional GAN) đã đưa thêm tham số điều kiện nhãn để kiểm soát và định hướng định dạng ảnh fake. Có nghĩa là khi chúng ta sử dụng model generator để sinh ảnh fake thì chúng ta có thể biết được trước nhãn, kiểu và định dạng của ảnh fake dựa trên tham số nhãn được đưa thêm vào mô hình. Xin trích dẫn :</p>

<p><code class="highlighter-rouge">Generative adversarial nets can be extended to a conditional model if both the generator and discriminator are conditioned on some extra information y. […] We can perform the conditioning by feeding y into the both the discriminator and generator as additional input layer.</code></p>

<p><a href="https://arxiv.org/abs/1411.1784">Conditional Generative Adversarial Nets, 2014</a></p>

<p>Cụ thể hơn về kiến trúc và phương pháp huấn luyện model CGAN chúng ta sẽ cùng tìm hiểu bên dưới.</p>

<h1 id="2-cgan">2. CGAN</h1>

<h2 id="21-kiến-trúc-model-cgan">2.1. Kiến trúc model CGAN</h2>

<p>Model DCGAN có đầu vào chỉ là véc tơ noise ngẫu nhiên $z$ được khởi tạo theo phân phối chuẩn hóa. Tuy nhiên ở model CGAN thì ở đầu vào sẽ có thêm nhãn $y$ như một tham số bổ sung cho mô hình <code class="highlighter-rouge">generator</code>. Chúng ta kỳ vọng rằng các bức ảnh fake được tạo ra sẽ nằm trong nhãn $y$. Đồng thời chúng ta cũng bổ sung nhãn $y$ vào <code class="highlighter-rouge">discriminator</code> để phân biệt tốt hơn ảnh real và ảnh fake. Cụ thể về kiến trúc model CGAN chúng ta có thể theo dõi qua hình bên dưới.</p>

<p><img src="https://miro.medium.com/max/700/1*4MxI-OrQqVMCCLbZXBV3rg.jpeg" class="normalpic" /></p>

<p><strong>Hình 1:</strong> Kiến trúc generator và discriminator của CGAN. Chúng ta thấy ở generator bên trái có đầu vào là véc tơ noise $z$ và nhãn $y$. Ảnh được sinh ra từ model generator là $G(z, y)$ sẽ giống với các ảnh thuộc class $y$ đầu vào. Đối với discriminator thì chúng ta cũng tiếp nhận đầu vào là ảnh $x$ và nhãn $y$. Ảnh $x$ có thể  là fake nếu được sinh ra từ mô hình generator hoặc là real nếu được lấy ra từ tập train. Discriminator sẽ nhằm mục tiêu dự đoán ảnh truyền vào là ảnh real hay ảnh fake.</p>

<p>Sơ đồ quá trình kết hợp giữa <code class="highlighter-rouge">generator</code> và <code class="highlighter-rouge">discriminator</code> chúng ta có thể theo dõi qua hình bên dưới:</p>

<p><img src="https://miro.medium.com/max/700/1*FpiLozEcc6-8RyiSTHjjIw.png" class="normalpic" /></p>

<p><strong>Hình 2:</strong> Kết hợp giữa generator và discriminator trong model CGAN. Đầu vào của discriminator là kết hợp giữa ảnh $x$ và nhãn $y$. $x$ có thể được lấy từ real image hoặc khởi tạo từ generator thông qua véc tơ $z$ nằm trong không gian ẩn (<em>latent space</em>).</p>

<h2 id="22-vai-trò-của-nhãn-y">2.2. Vai trò của nhãn y</h2>

<p>Lý do để chúng ta sử dụng nhãn $y$ trong mô hình CGAN đó là những thông tin đầu vào liên quan đến hình ảnh như nhãn là một trong những yếu tố giúp cải thiện chất lượng của model GAN. Sự cải thiện thể hiện ở mô hình ổn định hơn, quá trình huấn luyện nhanh hơn và chất lượng hình ảnh sinh ra tốt hơn. Nhãn đồng thời cũng là một trong những tham số giúp định hướng kết quả được sinh ra ở mô hình đầu ra theo ý muốn.</p>

<p>Trong trường hợp ảnh đưa vào mô hình là real như nhánh bên trái thì sẽ được gán nhãn 1 và nếu ảnh đưa vào mô hình là fake như nhánh bên phải thì sẽ được gán nhãn 0. Thông thường cũng giống như quá trình huấn luyện đối với model DCGAN thì tỷ lệ ảnh real/fake được truyền vào huấn luyện là 50:50. Chúng ta sẽ làm rõ hơn vấn đề phân chia tỷ lệ real/fake này ở phần thực hành.</p>

<h2 id="23-one-hot-embedding-cho-véc-tơ-nhãn-y">2.3. One-hot embedding cho véc tơ nhãn y</h2>

<p>Ngoài ra các bạn hẳn sẽ thắc mắc $y$ được concatenate với $x$ như thế nào để tạo thành đầu vào cho mô hình ?</p>

<p>Đầu tiên nhãn $y$ sẽ được chuyển thành một véc tơ one-hot có $n$ chiều trong đó $n$ là số lượng nhãn. Trong véc tơ one-hot chỉ có duy nhất một phần tử có giá trị bằng 1 tại vị trí tương ứng với nhãn $y$. Các vị trí còn lại bằng 0. VD: Nếu $y = 3$ thì sẽ được mã hóa thành véc tơ $(0, 0, 0, 1, 0, 0, 0, 0, 0, 0)$ mà ở đó vị trí thứ 4 có giá trị bằng 1. Lưu ý: 4 chính là vị trí của chữ số 3 trong các chữ số lần lượt từ $0-9$.</p>

<p>Sau khi đã mã hóa nhãn $y$ chúng ta sẽ concatenate với véc tơ $x$ đại diện cho bức ảnh có thể là real hoặc fake tùy ý. Véc tơ sau khi concatenate sẽ được sử dụng làm đầu vào cho discriminator.</p>

<h2 id="24-loss-function">2.4. Loss function</h2>

<p>Model CGAN cũng có loss function tương tự như model GAN. Loss function là kết hợp giữa loss function của model discriminator với model generator.</p>

<script type="math/tex; mode=display">\min_{G} \max_{D} V(D, G) = \underbrace{\mathbb{E}_{x \sim p_{data}(x)} [\log D(x)]}_{\text{log-probability that D predict x is real}} + \underbrace{\mathbb{E}_{z \sim p_{z}(z)} [\log (1-D(G(z)))]}_{\text{log-probability D predicts G(z) is fake}} ~~~ (1)</script>

<p>Để hiểu rõ hơn về các thành phần của loss function và tại sao loss function lại có tác dụng trong việc cải thiện đồng thời generator và discriminator, các bạn có thể xem lại <a href="https://phamdinhkhanh.github.io/2020/07/13/GAN.html#34-h%C3%A0m-loss-function">DCGAN loss function</a>.</p>

<p>Tiếp theo chúng ta sẽ cùng thực hành huấn luyện mô hình CGAN đối với các bức ảnh thời trang.</p>

<h1 id="3-thực-hành">3. Thực hành</h1>

<h2 id="31-dữ-liệu">3.1. Dữ liệu</h2>

<p>Dữ liệu mà chúng ta sẽ sử dụng để minh họa cho CGAN là bộ dữ liệu fashion-mnist, đây là bộ dữ liệu gồm 60000 bức ảnh trong đó tập train chiếm 50000 bức và tập test chiếm 10000 bức. Bộ dữ liệu được chia đều về 10 nhãn là các loại quần áo đặc trưng, kích thước của ảnh là <code class="highlighter-rouge">28 x 28</code> và ở định dạng ảnh một kênh màu. Bộ dữ liệu này được thay thế cho mnist để tăng thêm tính đa dạng và tránh sự lặp lại nhàm chán. Cả hai tập dữ liệu fashion-mnist và mnist là hai bộ dữ liệu thường được sử dụng để demo các thuật toán trong giảng dạy và học tập. Do đó chúng đã được tích hợp sẵn trong các framework phổ biến như tensorflow, pytorch.</p>

<p>Để load dữ liệu train, test của fashion-mnist trên keras, chúng ta sẽ thực hiện như bên dưới :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>from google.colab import drive
import os

drive.mount("/content/gdrive")
path = "gdrive/My Drive/Colab Notebooks/GAN"
os.chdir(path)

from tensorflow.keras.datasets.fashion_mnist import load_data

(X_train, y_train), (X_test, y_test) = load_data()
# Shape model
print('Train shape: ', X_train.shape, y_train.shape)
print('Test shape : ', X_test.shape, y_test.shape)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre>Train shape:  (60000, 28, 28) (60000,)
Test shape :  (10000, 28, 28) (10000,)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Tiếp theo chúng ta sẽ khảo sát ngẫu nhiên 10 hình ảnh thuộc bộ dữ liệu này :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="rouge-code"><pre>import matplotlib.pyplot as plt
import numpy as np


class_names = {
    0: "T-shirt/top",
  1: "Trouser/pants",
  2: "Pullover shirt",
  3: "Dress",
  4: "Coat",
  5: "Sandal",
  6: "Shirt",
  7: "Sneaker",
  8: "Bag",
  9: "Ankle boot"
}

idxs = np.arange(X_train.shape[0])
plt.figure(figsize=(20, 8))
for i, idx in enumerate(np.random.choice(idxs, 10)):
    plt.subplot(2, 5, i+1)
    plt.xticks([])
    plt.yticks([])
    plt.grid(False)
    plt.imshow(X_train[idx])
    # Nếu muốn show ảnh gray thì thay lệnh plt.imshow() ở trên bằng lệnh bên dưới.
    # plt.imshow(X_train[idx], c_map='gray_r')
    plt.xlabel(class_names[y_train[idx]])
plt.show()
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200809_ConditionalGAN/ConditionalGAN_14_0.png" class="l" /></p>

<p>Ta nhận thấy các bức ảnh đều có độ phân giải thấp để giảm thiểu khối lượng tính toán cho demo. Phông nền của hình ảnh là màu đen tương ứng với các điểm ảnh có giá trị cường độ là 0. Phần trung tâm của bức ảnh là các bộ quần áo, giày có giá trị cường độ lớn hơn 0.</p>

<h2 id="32-kiến-trúc-mô-hình">3.2. Kiến trúc mô hình</h2>

<p>Tương tự như các thuật toán GAN khác, kiến trúc của CGAN cũng bao gồm 2 phases là generator và discriminator. Trong đó generator có tác dụng sinh ảnh và discriminator sẽ phân biệt giữa ảnh real và ảnh fake. Tuy nhiên trong model CGAN thì chúng ta sẽ có thêm <em>điều kiện</em> của ảnh output bằng cách thêm véc tơ one-hot encoding của nhãn bức ảnh mà chúng ta muốn tạo cho cả generator và discriminator.</p>

<h3 id="321-discriminator">3.2.1 discriminator</h3>

<p>Đầu vào của discriminator sẽ là một véc tơ concatenate giữa véc tơ biểu diễn ảnh với véc tơ one-hot của nhãn bức ảnh. Véc tơ one-hot của nhãn sau đó sẽ chiếu lên một không gian mới 50 chiều thông qua một phép chiếu linear-projection.</p>

<p>Backbone (tức là mạng CNN cơ sở) mà chúng ta sử dụng để huấn luyện model CGAN là một kiến trúc CNN thông thường làm nhiệm vụ trích suất các đặc trưng của ảnh. Bạn đọc có thể sử dụng thử bất kỳ một kiến trúc CNN model nào đã được trình bày tại <a href="https://phamdinhkhanh.github.io/2020/05/31/CNNHistory.html">Bài 38 - Các kiến trúc CNN hiện đại</a>. Hoặc có thể tự tạo cho mình một kiến trúc CNN tùy ý. Việc tạo kiến trúc CNN là không quá khó khăn, chúng ta có thể sử dụng các block CNN <em>[Conv + BatchNorm + Maxpooling]</em> liên tiếp nhau để giảm chiều dữ liệu. Output của layer CNN cuối cùng sẽ được trải phẳng (flatten) thành một véc tơ và sử dụng các kết nối fully connected để thu được đầu ra với số lượng class mong muốn.</p>

<p>Bạn đọc sẽ hiểu rõ hơn qua phần thực hành bên dưới :</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre></td><td class="rouge-code"><pre><span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span> <span class="n">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">Conv2DTranspose</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">LeakyReLU</span><span class="p">,</span> <span class="n">Embedding</span><span class="p">,</span> <span class="n">Concatenate</span><span class="p">,</span> <span class="n">Reshape</span><span class="p">,</span> <span class="n">Flatten</span><span class="p">,</span> <span class="n">Dropout</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span> <span class="n">import</span> <span class="k">Model</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span> <span class="n">import</span> <span class="n">Adam</span>

<span class="n">def</span> <span class="n">_discriminator</span><span class="p">(</span><span class="n">input_shape</span><span class="p">=(</span><span class="m">28</span><span class="p">,</span> <span class="m">28</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">n_classes</span> <span class="p">=</span> <span class="m">10</span><span class="p">):</span>
  <span class="p">#</span> <span class="m">1.</span> <span class="n">Kh</span><span class="err">ở</span><span class="n">i</span> <span class="n">t</span><span class="err">ạ</span><span class="n">o</span> <span class="n">nh</span><span class="err">á</span><span class="n">nh</span> <span class="n">input</span> <span class="n">l</span><span class="err">à</span> <span class="n">y_label</span>
  <span class="n">y_label</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="p">=(</span><span class="m">1</span><span class="p">,))</span>
  <span class="p">#</span> <span class="n">Embedding</span> <span class="n">y_label</span> <span class="n">v</span><span class="err">à</span> <span class="n">chi</span><span class="err">ế</span><span class="n">u</span> <span class="n">l</span><span class="err">ê</span><span class="n">n</span> <span class="n">kh</span><span class="err">ô</span><span class="n">ng</span> <span class="n">gian</span> <span class="n">v</span><span class="err">é</span><span class="n">c</span> <span class="n">t</span><span class="err">ơ</span> <span class="m">50</span> <span class="n">dimension</span><span class="p">.</span>
  <span class="n">y_embedding</span> <span class="p">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">n_classes</span><span class="p">,</span> <span class="m">50</span><span class="p">)(</span><span class="n">y_label</span><span class="p">)</span>
  <span class="p">#</span> <span class="n">Gia</span> <span class="n">t</span><span class="err">ă</span><span class="n">ng</span> <span class="n">k</span><span class="err">í</span><span class="n">ch</span> <span class="n">th</span><span class="err">ướ</span><span class="n">c</span> <span class="n">y_embedding</span> <span class="n">th</span><span class="err">ô</span><span class="n">ng</span> <span class="n">qua</span> <span class="n">linear</span> <span class="n">projection</span>
  <span class="n">n_shape</span> <span class="p">=</span> <span class="n">input_shape</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">*</span> <span class="n">input_shape</span><span class="p">[</span><span class="m">1</span><span class="p">]</span>
  <span class="n">li</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">n_shape</span><span class="p">)(</span><span class="n">y_embedding</span><span class="p">)</span>
  <span class="n">li</span> <span class="p">=</span> <span class="n">Reshape</span><span class="p">((</span><span class="n">input_shape</span><span class="p">[</span><span class="m">0</span><span class="p">],</span> <span class="n">input_shape</span><span class="p">[</span><span class="m">1</span><span class="p">],</span> <span class="m">1</span><span class="p">))(</span><span class="n">li</span><span class="p">)</span>
  
  <span class="p">#</span> <span class="m">2.</span> <span class="n">Kh</span><span class="err">ở</span><span class="n">i</span> <span class="n">t</span><span class="err">ạ</span><span class="n">o</span> <span class="n">nh</span><span class="err">á</span><span class="n">nh</span> <span class="n">input</span> <span class="n">l</span><span class="err">à</span> <span class="n">image</span>
  <span class="n">inpt_image</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="p">=(</span><span class="m">28</span><span class="p">,</span> <span class="m">28</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
  
  <span class="p">#</span> <span class="m">3.</span> <span class="n">Concate</span> <span class="n">y_label</span> <span class="n">v</span><span class="err">à</span> <span class="n">image</span>
  <span class="n">concat</span> <span class="p">=</span> <span class="n">Concatenate</span><span class="p">()([</span><span class="n">inpt_image</span><span class="p">,</span> <span class="n">li</span><span class="p">])</span>
  <span class="p">#</span> <span class="m">4.</span> <span class="n">Feature</span> <span class="n">extractor</span> <span class="n">th</span><span class="err">ô</span><span class="n">ng</span> <span class="n">qua</span> <span class="n">CNN</span> <span class="n">blocks</span><span class="p">:</span>
  <span class="n">fe</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="m">128</span><span class="p">,</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">3</span><span class="p">),</span> <span class="n">strides</span><span class="p">=(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">),</span> <span class="n">padding</span><span class="p">=</span><span class="s1">'same'</span><span class="p">)(</span><span class="n">concat</span><span class="p">)</span>
  <span class="n">fe</span> <span class="p">=</span> <span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">=</span><span class="m">0.2</span><span class="p">)(</span><span class="n">fe</span><span class="p">)</span>
  
  <span class="n">fe</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="m">128</span><span class="p">,</span> <span class="p">(</span><span class="m">3</span><span class="p">,</span><span class="m">3</span><span class="p">),</span> <span class="n">strides</span><span class="p">=(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">),</span> <span class="n">padding</span><span class="p">=</span><span class="s1">'same'</span><span class="p">)(</span><span class="n">fe</span><span class="p">)</span>
  <span class="n">fe</span> <span class="p">=</span> <span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">=</span><span class="m">0.2</span><span class="p">)(</span><span class="n">fe</span><span class="p">)</span>
  
  <span class="p">#</span> <span class="n">Flatten</span> <span class="n">output</span>
  <span class="n">fe</span> <span class="p">=</span> <span class="n">Flatten</span><span class="p">()(</span><span class="n">fe</span><span class="p">)</span>
  <span class="n">fe</span> <span class="p">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="m">0.4</span><span class="p">)(</span><span class="n">fe</span><span class="p">)</span>
  <span class="n">out_layer</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'sigmoid'</span><span class="p">)(</span><span class="n">fe</span><span class="p">)</span>

  <span class="p">#</span> <span class="n">Kh</span><span class="err">ở</span><span class="n">i</span> <span class="n">t</span><span class="err">ạ</span><span class="n">o</span> <span class="k">model</span>
  <span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">([</span><span class="n">inpt_image</span><span class="p">,</span> <span class="n">y_label</span><span class="p">],</span> <span class="n">out_layer</span><span class="p">)</span>
  <span class="n">opt</span> <span class="p">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">lr</span><span class="p">=</span><span class="m">0.0002</span><span class="p">,</span> <span class="n">beta_1</span><span class="p">=</span><span class="m">0.5</span><span class="p">)</span>
  <span class="k">model</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">loss</span><span class="p">=</span><span class="s1">'binary_crossentropy'</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">=</span><span class="n">opt</span><span class="p">,</span> <span class="n">metrics</span><span class="p">=[</span><span class="s1">'accuracy'</span><span class="p">])</span>
  <span class="n">return</span> <span class="k">model</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Đồ thị của mô hình bên dưới cho chúng ta thấy rằng đầu vào của mô hình được concatenate từ hai nhánh. Một nhánh đọc dữ liệu từ các bức ảnh và một nhánh còn lại sẽ embedding nhãn thành một véc tơ 50 chiều. Sau khi concatenate dữ liệu thì chúng sẽ được truyền qua các CNN layer để trích lọc đặc trưng phục vụ cho mục đích phân loại ảnh real và fake. Đầu ra của mô hình discriminator chỉ bao gồm một unit dự báo xác suất thuộc về ảnh real hoặc fake.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>from tensorflow.keras.utils import plot_model

discriminator = _discriminator(input_shape=(28, 28, 1), n_classes=10)
plot_model(discriminator)
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200809_ConditionalGAN/ConditionalGAN_20_0.png" class="largepic" /></p>

<p>Tiếp theo chúng ta sẽ cùng tim hiểu generator</p>

<h3 id="322-generator">3.2.2. Generator</h3>

<p>Generator có tác dụng là sinh ra ảnh fake. Do đó đây là một mô hình image2image và chúng ta cần sử dụng <a href="https://phamdinhkhanh.github.io/2020/06/10/ImageSegmention.html#5-m%E1%BA%A1ng-gi%E1%BA%A3i-ch%E1%BA%ADp-deconvolutional-neural-network">kiến trúc mạng giải chập</a> để biến đổi các features ngược trở lại ảnh gốc.</p>

<p>Đầu vào của generator cũng bao gồm 2 nhánh, một nhánh là véc tơ noise gồm 100 chiều tương tự như trong model DCGAN. Nhánh còn lại ghi nhận thông tin về nhãn của ảnh mà chúng ta muốn mô hình biến đổi. Nhãn sẽ được one-hot encoding để tạo thành những thông tin mới được xem như là điều kiện để model geneartor tạo ra ảnh.</p>

<p>Hai nhánh sau đó được concatenate với nhau tạo ra một input vừa chứa đầu vào là véc tơ ngẫu nhiên $x$ và vừa chứa điều kiện về nhãn $y$. Do đó chúng ta có thể kiểm soát được bức ảnh sinh ra thông qua việc điều chỉnh điều kiện $y$.</p>

<p>Một mạng giải chập được sử dụng để tăng dần kích thước các layers về bằng với bức ảnh gốc.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre></td><td class="rouge-code"><pre><span class="n">def</span> <span class="n">_generator</span><span class="p">(</span><span class="n">latent_dim</span><span class="p">=</span><span class="m">100</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">=</span><span class="m">10</span><span class="p">):</span>
  <span class="p">#</span> <span class="m">1.</span> <span class="n">Kh</span><span class="err">ở</span><span class="n">i</span> <span class="n">t</span><span class="err">ạ</span><span class="n">o</span> <span class="n">nh</span><span class="err">á</span><span class="n">nh</span> <span class="err">đầ</span><span class="n">u</span> <span class="n">v</span><span class="err">à</span><span class="n">o</span> <span class="n">l</span><span class="err">à</span> <span class="n">y_label</span>
  <span class="n">y_label</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="p">=(</span><span class="m">1</span><span class="p">,))</span>
  <span class="p">#</span> <span class="n">embedding</span> <span class="n">v</span><span class="err">é</span><span class="n">c</span> <span class="n">t</span><span class="err">ơ</span> <span class="n">categorical</span> <span class="err">đầ</span><span class="n">u</span> <span class="n">v</span><span class="err">à</span><span class="n">o</span>
  <span class="n">li</span> <span class="p">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">n_classes</span><span class="p">,</span> <span class="m">50</span><span class="p">)(</span><span class="n">y_label</span><span class="p">)</span>
  <span class="n">n_shape</span> <span class="p">=</span> <span class="m">7</span> <span class="p">*</span> <span class="m">7</span>
  <span class="n">li</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">n_shape</span><span class="p">)(</span><span class="n">li</span><span class="p">)</span>
  <span class="p">#</span> <span class="n">reshape</span> <span class="n">l</span><span class="err">ạ</span><span class="n">i</span> <span class="err">đầ</span><span class="n">u</span> <span class="n">v</span><span class="err">à</span><span class="n">o</span> <span class="n">v</span><span class="err">ề</span> <span class="n">k</span><span class="err">í</span><span class="n">ch</span> <span class="n">th</span><span class="err">ướ</span><span class="n">c</span> <span class="m">7</span><span class="n">x7x1</span> <span class="n">nh</span><span class="err">ư</span> <span class="n">m</span><span class="err">ộ</span><span class="n">t</span> <span class="n">channel</span> <span class="n">b</span><span class="err">ổ</span> <span class="n">sung</span><span class="p">.</span>
  <span class="n">li</span> <span class="p">=</span> <span class="n">Reshape</span><span class="p">((</span><span class="m">7</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">1</span><span class="p">))(</span><span class="n">li</span><span class="p">)</span>

  <span class="p">#</span> <span class="m">2.</span> <span class="n">Kh</span><span class="err">ở</span><span class="n">i</span> <span class="n">t</span><span class="err">ạ</span><span class="n">o</span> <span class="n">nh</span><span class="err">á</span><span class="n">nh</span> <span class="err">đầ</span><span class="n">u</span> <span class="n">v</span><span class="err">à</span><span class="n">o</span> <span class="n">l</span><span class="err">à</span> <span class="n">v</span><span class="err">é</span><span class="n">c</span> <span class="n">t</span><span class="err">ơ</span> <span class="n">noise</span> <span class="n">x</span>
  <span class="n">in_lat</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="p">=(</span><span class="n">latent_dim</span><span class="p">,))</span>
  <span class="n">n_shape</span> <span class="p">=</span> <span class="m">128</span> <span class="p">*</span> <span class="m">7</span> <span class="p">*</span> <span class="m">7</span>
  <span class="n">gen</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">n_shape</span><span class="p">)(</span><span class="n">in_lat</span><span class="p">)</span>
  <span class="n">gen</span> <span class="p">=</span> <span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">=</span><span class="m">0.2</span><span class="p">)(</span><span class="n">gen</span><span class="p">)</span>
  <span class="p">#</span> <span class="n">Bi</span><span class="err">ế</span><span class="n">n</span> <span class="err">đổ</span><span class="n">i</span> <span class="n">v</span><span class="err">ề</span> <span class="n">k</span><span class="err">í</span><span class="n">ch</span> <span class="n">th</span><span class="err">ướ</span><span class="n">c</span> <span class="m">7</span><span class="n">x7x128</span>
  <span class="n">gen</span> <span class="p">=</span> <span class="n">Reshape</span><span class="p">((</span><span class="m">7</span><span class="p">,</span> <span class="m">7</span><span class="p">,</span> <span class="m">128</span><span class="p">))(</span><span class="n">gen</span><span class="p">)</span>

  <span class="p">#</span> <span class="m">3.</span> <span class="n">Merge</span> <span class="n">nh</span><span class="err">á</span><span class="n">nh</span> <span class="m">1</span> <span class="n">v</span><span class="err">à</span> <span class="n">nh</span><span class="err">á</span><span class="n">nh</span> <span class="m">2</span>
  <span class="n">merge</span> <span class="p">=</span> <span class="n">Concatenate</span><span class="p">()([</span><span class="n">gen</span><span class="p">,</span> <span class="n">li</span><span class="p">])</span>

  <span class="p">#</span> <span class="m">4.</span> <span class="n">S</span><span class="err">ử</span> <span class="n">d</span><span class="err">ụ</span><span class="n">ng</span> <span class="n">Conv2DTranspose</span> <span class="err">để</span> <span class="n">gi</span><span class="err">ả</span><span class="n">i</span> <span class="n">ch</span><span class="err">ậ</span><span class="n">p</span> <span class="n">v</span><span class="err">ề</span> <span class="n">k</span><span class="err">í</span><span class="n">ch</span> <span class="n">th</span><span class="err">ướ</span><span class="n">c</span> <span class="n">ban</span> <span class="err">đầ</span><span class="n">u</span><span class="p">.</span>
  <span class="n">gen</span> <span class="p">=</span> <span class="n">Conv2DTranspose</span><span class="p">(</span><span class="m">128</span><span class="p">,</span> <span class="p">(</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">),</span> <span class="n">strides</span><span class="p">=(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">),</span> <span class="n">padding</span><span class="p">=</span><span class="s1">'same'</span><span class="p">)(</span><span class="n">merge</span><span class="p">)</span>
  <span class="n">gen</span> <span class="p">=</span> <span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">=</span><span class="m">0.2</span><span class="p">)(</span><span class="n">gen</span><span class="p">)</span>

  <span class="n">gen</span> <span class="p">=</span> <span class="n">Conv2DTranspose</span><span class="p">(</span><span class="m">128</span><span class="p">,</span> <span class="p">(</span><span class="m">4</span><span class="p">,</span><span class="m">4</span><span class="p">),</span> <span class="n">strides</span><span class="p">=(</span><span class="m">2</span><span class="p">,</span><span class="m">2</span><span class="p">),</span> <span class="n">padding</span><span class="p">=</span><span class="s1">'same'</span><span class="p">)(</span><span class="n">gen</span><span class="p">)</span>
  <span class="n">gen</span> <span class="p">=</span> <span class="n">LeakyReLU</span><span class="p">(</span><span class="n">alpha</span><span class="p">=</span><span class="m">0.2</span><span class="p">)(</span><span class="n">gen</span><span class="p">)</span>
  <span class="p">#</span> <span class="n">output</span>
  <span class="n">out_layer</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="p">(</span><span class="m">7</span><span class="p">,</span><span class="m">7</span><span class="p">),</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'tanh'</span><span class="p">,</span> <span class="n">padding</span><span class="p">=</span><span class="s1">'same'</span><span class="p">)(</span><span class="n">gen</span><span class="p">)</span>
  <span class="p">#</span> <span class="k">model</span>
  <span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">([</span><span class="n">in_lat</span><span class="p">,</span> <span class="n">y_label</span><span class="p">],</span> <span class="n">out_layer</span><span class="p">)</span>
  <span class="n">return</span> <span class="k">model</span>

<span class="n">generator</span> <span class="p">=</span> <span class="n">_generator</span><span class="p">(</span><span class="n">latent_dim</span><span class="p">=</span><span class="m">100</span><span class="p">,</span> <span class="n">n_classes</span><span class="p">=</span><span class="m">10</span><span class="p">)</span>
<span class="n">plot_model</span><span class="p">(</span><span class="n">generator</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20200809_ConditionalGAN/ConditionalGAN_23_0.png" class="lpic" /></p>

<h3 id="323-cgan-model">3.2.3. CGAN model</h3>

<p>Tiếp theo chúng ta sẽ cùng khởi tạo model CGAN từ hai model generator và discriminator.</p>

<ul>
  <li>
    <p>Đầu tiên dữ liệu sẽ được truyền qua generator model để thu được đầu ra là một bức ảnh. Lưu ý input của generator trong CGAN ngoài véc tơ noise sẽ có thêm label so với model GAN.</p>
  </li>
  <li>
    <p>Tiếp theo output của generator sẽ được truyền vào model discriminator để phân biệt ảnh real và ảnh fake. Input của discriminator cũng bao gồm ảnh được sinh ra từ generator và label.</p>
  </li>
  <li>
    <p>CGAN model sẽ là một pipeline end2end kết hợp generator và discriminator. Chúng ta sẽ thông qua CGAN để huấn luyện generator. Do đó discriminator sẽ được đóng băng.</p>
  </li>
</ul>

<p>Hàm loss function của CGAN sẽ giống như DCGAN và là một hàm dạng <code class="highlighter-rouge">binary_crossentropy</code>.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre></td><td class="rouge-code"><pre><span class="n">def</span> <span class="n">_cgan</span><span class="p">(</span><span class="n">g_model</span><span class="p">,</span> <span class="n">d_model</span><span class="p">):</span>
	<span class="p">#</span> <span class="k">Do</span> <span class="n">cgan</span> <span class="err">đượ</span><span class="n">c</span> <span class="n">s</span><span class="err">ử</span> <span class="n">d</span><span class="err">ụ</span><span class="n">ng</span> <span class="err">để</span> <span class="n">hu</span><span class="err">ấ</span><span class="n">n</span> <span class="n">luy</span><span class="err">ệ</span><span class="n">n</span> <span class="n">generator</span> <span class="n">n</span><span class="err">ê</span><span class="n">n</span> <span class="n">discriminator</span> <span class="n">s</span><span class="err">ẽ</span> <span class="err">đượ</span><span class="n">c</span> <span class="err">đó</span><span class="n">ng</span> <span class="n">b</span><span class="err">ă</span><span class="n">ng</span>
	<span class="n">d_model</span><span class="p">.</span><span class="n">trainable</span> <span class="p">=</span> <span class="nb">False</span>
	<span class="p">#</span> <span class="n">L</span><span class="err">ấ</span><span class="n">y</span> <span class="err">đầ</span><span class="n">u</span> <span class="n">v</span><span class="err">à</span><span class="n">o</span> <span class="n">c</span><span class="err">ủ</span><span class="n">a</span> <span class="n">generator</span> <span class="k">model</span> <span class="n">bao</span> <span class="n">g</span><span class="err">ồ</span><span class="n">m</span> <span class="n">v</span><span class="err">é</span><span class="n">c</span> <span class="n">t</span><span class="err">ơ</span> <span class="n">noise</span> <span class="n">v</span><span class="err">à</span> <span class="n">nh</span><span class="err">ã</span><span class="n">n</span>
	<span class="n">gen_noise</span><span class="p">,</span> <span class="n">gen_label</span> <span class="p">=</span> <span class="n">g_model</span><span class="p">.</span><span class="n">input</span>
	<span class="p">#</span> <span class="n">L</span><span class="err">ấ</span><span class="n">y</span> <span class="err">ả</span><span class="n">nh</span> <span class="n">sinh</span> <span class="n">ra</span> <span class="n">t</span><span class="err">ừ</span> <span class="n">generator</span> <span class="k">model</span>
	<span class="n">gen_output</span> <span class="p">=</span> <span class="n">g_model</span><span class="p">.</span><span class="n">output</span>
	<span class="p">#</span> <span class="n">Truy</span><span class="err">ề</span><span class="n">n</span> <span class="n">output</span> <span class="n">v</span><span class="err">à</span> <span class="n">nh</span><span class="err">ã</span><span class="n">n</span> <span class="n">c</span><span class="err">ủ</span><span class="n">a</span> <span class="n">m</span><span class="err">ô</span> <span class="n">h</span><span class="err">ì</span><span class="n">nh</span> <span class="n">generator</span> <span class="n">v</span><span class="err">à</span><span class="n">o</span> <span class="n">m</span><span class="err">ô</span> <span class="n">h</span><span class="err">ì</span><span class="n">nh</span> <span class="n">discriminator</span>
	<span class="n">gan_output</span> <span class="p">=</span> <span class="n">d_model</span><span class="p">([</span><span class="n">gen_output</span><span class="p">,</span> <span class="n">gen_label</span><span class="p">])</span>
	<span class="p">#</span> <span class="n">Kh</span><span class="err">ở</span><span class="n">i</span> <span class="n">t</span><span class="err">ạ</span><span class="n">o</span> <span class="n">m</span><span class="err">ô</span> <span class="n">h</span><span class="err">ì</span><span class="n">nh</span> <span class="n">CGAN</span>
	<span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">([</span><span class="n">gen_noise</span><span class="p">,</span> <span class="n">gen_label</span><span class="p">],</span> <span class="n">gan_output</span><span class="p">)</span>
	<span class="n">opt</span> <span class="p">=</span> <span class="n">Adam</span><span class="p">(</span><span class="n">lr</span><span class="p">=</span><span class="m">0.0002</span><span class="p">,</span> <span class="n">beta_1</span><span class="p">=</span><span class="m">0.5</span><span class="p">)</span>
	<span class="k">model</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">loss</span><span class="p">=</span><span class="s1">'binary_crossentropy'</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">=</span><span class="n">opt</span><span class="p">)</span>
	<span class="n">return</span> <span class="k">model</span>

<span class="n">cgan_model</span> <span class="p">=</span> <span class="n">_cgan</span><span class="p">(</span><span class="n">generator</span><span class="p">,</span> <span class="n">discriminator</span><span class="p">)</span>
<span class="n">plot_models</span><span class="p">(</span><span class="n">cgan_model</span><span class="p">)</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<h3 id="324-huấn-luyện-model">3.2.4. Huấn luyện model</h3>

<p>Để quá trình huấn luyện ổn định hơn chúng ta sẽ chuẩn hóa các giá trị cường độ pixel ảnh về khoảng $[-1, 1]$ thông qua công thức.</p>

<script type="math/tex; mode=display">x_{std} = \frac{x-127.5}{127.5}</script>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="rouge-code"><pre># Hàm chuẩn hóa dữ liệu huấn luyện
def _standardize_data(X_train, y_train):
	X = np.expand_dims(X_train, axis=-1)
	X = X.astype('float32')
  # chuẩn hóa dữ liệu về khoảng [-1, 1]
	X = (X - 127.5) / 127.5
	return [X, y_train]
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Tiếp theo chúng ta sẽ lựa chọn ra ngẫu nhiên <code class="highlighter-rouge">n_samples</code> từ dữ liệu thật làm ảnh real để huấn luyện mô hình</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre># Lựa chọn ngẫu nhiên các dữ liệu huấn luyện
def _generate_real_samples(dataset, n_samples):
	images, labels = dataset
	# Lựa chọn n_samples index ảnh
	ix = np.random.randint(0, images.shape[0], n_samples)
	# Lựa chọn ngẫu nhiên n_sample từ index.
	X, labels = images[ix], labels[ix]
  # Khởi tạo nhãn 1 cho ảnh real
	y = np.ones((n_samples, 1))
	return [X, labels], y
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Tương tự chúng ta cũng tạo ra một batch gồm <code class="highlighter-rouge">n_samples</code> từ dữ liệu fake được sinh ra từ generator model.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre># Sinh ra các véc tơ noise trong không gian latent space làm đầu vào cho generator
def _generate_latent_points(latent_dim, n_samples, n_classes=10):
	# Khởi tạo các points trong latent space
	x_input = np.random.randn(latent_dim * n_samples)
	# reshape thành batch để feed vào generator.
	z_input = x_input.reshape(n_samples, latent_dim)
	# khởi tạo labels một cách ngẫu nhiên.
	labels = np.random.randint(0, n_classes, n_samples)
	return [z_input, labels]
 
# Sử dụng generator để sinh ra n_samples ảnh fake.
def _generate_fake_samples(generator, latent_dim, n_samples):
	# Khởi tạo các điểm ngẫu nhiên trong latent space.
	z_input, labels_input = _generate_latent_points(latent_dim, n_samples)
	# Dự đoán outputs từ generator
	images = generator.predict([z_input, labels_input])
	# Khởi tạo nhãn 0 cho ảnh fake
	y = np.zeros((n_samples, 1))
	return [images, labels_input], y
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Tiếp theo chúng ta sẽ huấn luyện mô hình một cách xen kẽ giữa generator và discriminator. Quá trình huấn luyện trên mỗi batch như sau:</p>

<ul>
  <li>Huấn luyện mô hình trên discriminator trước. Trong đó 1/2 batch là ảnh real và 1/2 batch còn lại là ảnh fake.</li>
  <li>Huấn luyện mô hình trên generator thông qua huấn luyện model CGAN trên 1 batch.</li>
</ul>

<p>Sau mỗi mặc định 10 epochs thì model CGAN sẽ được lưu lại.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre></td><td class="rouge-code"><pre>def _train(g_model, d_model, cgan_model, dataset, latent_dim, n_epochs=100, n_batch=128, save_every_epochs=10):
	'''
	g_model: generator model
	d_model: discriminator model
	cgan_model: gan_model
	dataset: dữ liệu huấn luyện, bao gồm: (X_train, y_train)
	latent_dim: Số chiều của latent space
	n_epochs: Số lượng epochs
	n_batch: Kích thước batch_size
	save_every_epochs: Số lượng epochs mà chúng ta sẽ save model.
	'''
	# Tính số lượng batch trên một epochs
	batch_per_epoch = int(dataset[0].shape[0] / n_batch)
	half_batch = int(n_batch / 2)
	# Huấn luyện mô hình qua từng epochs
	for i in range(n_epochs):
		# Khởi tạo batch trên tập train
		for j in range(batch_per_epoch):
			# 1. Huấn luyện model discrinator
			# Khởi tạo batch cho ảnh real ngẫu nhiên
			[X_real, labels_real], y_real = _generate_real_samples(dataset, half_batch)
			# Cập nhật discriminator model weights
			d_loss1, _ = d_model.train_on_batch([X_real, labels_real], y_real)
			# Khởi tạo batch cho ảnh fake ngẫu nhiên
			[X_fake, labels], y_fake = _generate_fake_samples(g_model, latent_dim, half_batch)
			# Cập nhật weights cho discriminator model
			d_loss2, _ = d_model.train_on_batch([X_fake, labels], y_fake)
	 		# 2. Huấn luyện model generator
			# Khởi tạo các điểm ngẫu nhiên trong latent space như là đầu vào cho generator
			[z_input, labels_input] = _generate_latent_points(latent_dim, n_batch)
			# Khởi tạo nhãn discriminator cho các dữ liệu fake. Do chúng ta giả định là generator đánh lừa được discriminator nên nhãn của ảnh là 1.
			y_gan = np.ones((n_batch, 1))
			# Huấn luyện generator thông qua model CGAN
			g_loss = cgan_model.train_on_batch([z_input, labels_input], y_gan)
			# summarize loss on this batch
			print('&gt;%d, %d/%d, d1=%.3f, d2=%.3f g=%.3f' %
				(i+1, j+1, batch_per_epoch, d_loss1, d_loss2, g_loss))
	if (i % save_every_epochs) &amp; (i &gt; 0):
		g_model.save('cgan_generator_epoch{}.h5'.format(i))
	# save the generator model
	g_model.save('cgan_generator.h5')
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Huấn luyện model.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="rouge-code"><pre># Kích thước latent space
latent_dim = 100
# Khởi tạo discriminator
d_model = _discriminator()
# Khởi tạo generator
g_model = _generator(latent_dim)
# Khởi tạo cgan
cgan_model = _cgan(g_model, d_model)
# load image data
dataset = _standardize_data(X_train, y_train)
# train model
_train(g_model, d_model, cgan_model, dataset, latent_dim)
</pre></td></tr></tbody></table></code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>&gt;100, 468/468, d1=0.672, d2=0.673 g=0.768
</pre></td></tr></tbody></table></code></pre></div></div>

<h1 id="4-kết-luậnarge">4. Kết luậnarge</h1>

<p>Như vậy với model CGAN, chúng ta đã kiểm soát được những bức ảnh được tạo ra theo ý muốn. Đây có thể được xem như một bước đột phát của GAN vì trên thực tế có rất nhiều những bức ảnh mà ta sẽ phải định hướng kết quả về hình dạng, format. CGAN cũng tạo ra những đột phá mới về chất lượng hình ảnh và sự ổn định trong quá trình huấn luyện. Qua bài viết này các bạn đã nắm được kiến trúc của một model CGAN và quá trình để huấn luyện một model CGAN điển hình trên bộ dữ liệu fashion-mnist. Đây sẽ là tiền đề để chúng ta vận dụng model CGAN trên những bộ dữ liệu khác.</p>

<p>Code mẫu của mô hình được cung cấp tại <a href="https://github.com/phamdinhkhanh/CGAN">CGAN model</a>.</p>

<h1 id="5-tham-khảo">5. Tham khảo</h1>

<ol>
  <li>
    <p><a href="https://phamdinhkhanh.github.io/2020/07/13/GAN.html">GAN</a></p>
  </li>
  <li>
    <p><a href="https://phamdinhkhanh.github.io/2020/07/25/GAN_Wasserstein.html">Wasserstein GAN</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/@jonathan_hui/gan-cgan-infogan-using-labels-to-improve-gan-8ba4de5f9c3d">GAN — CGAN &amp; InfoGAN (using labels to improve GAN) - Jonathan Hui</a></p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/1411.1784">Conditional Generative Adversarial Nets - origin paper - Mehdi Mirza, Simon Osindero</a></p>
  </li>
  <li>
    <p><a href="https://machinelearningmastery.com/how-to-develop-a-conditional-generative-adversarial-network-from-scratch/">Conditional GAN network - machinelearning mastery</a></p>
  </li>
  <li>
    <p><a href="http://cs231n.stanford.edu/reports/2015/pdfs/jgauthie_final_report.pdf">Conditional GAN - cs231 standford</a></p>
  </li>
  <li>
    <p><a href="https://medium.com/ai-in-plain-english/review-cgan-conditional-gan-gan-78dd42eee41">Generative Adversarial Network (GAN) with Extra Conditional Inputs - Sik-Ho Tsang</a></p>
  </li>
  <li>
    <p><a href="https://arxiv.org/abs/2007.04589">InfoMax-GAN: Improved Adversarial Image Generation via Information Maximization and Contrastive Learning - Kwot Sin Lee, Ngoc-Trung Tran, Ngai-Man Cheung</a></p>
  </li>
</ol>


<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>

<script src="/js/toc.js"></script>
<script src="/js/btnTop.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
});
</script>
				</div>
			</div>
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/logo.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Khanh's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/TowardDataScience">phamdinhkhanh blog</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/3235479620010379/">phamdinhkhanh AICode forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://kaggle.com/phamdinhkhanh">phamdinhkhanh kaggle</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://rpubs.com/phamdinhkhanh">phamdinhkhanh rpub</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://github.com/phamdinhkhanh">phamdinhkhanh github</a></li>
					<br>
					<div class="header">other's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/machinelearningcoban/">machine learning cơ bản facebook</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://forum.machinelearningcoban.com/">machine learning cơ bản forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://machinelearningmastery.com">machine learning mastery</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://viblo.asia">viblosia</a></li>
					<br>
					<div class="header">Khóa học</div>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs109/">Xác suất thống kê(Probability): CS109</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs246/">Bigdata: CS246</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://cs231n.stanford.edu/">Computer vision cơ bản: CS231N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224n/">Natural Language Processing: CS224N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224w/">Khoá phân tích mạng lưới (analysis of network): CS224W</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://web.stanford.edu/class/cs20si/">Khóa học Tensorflow: CS20SI</a></li>
				</nav>
			</div>
		</div>
	</div>
	
</body>
</html>
