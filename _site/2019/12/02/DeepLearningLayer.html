<!DOCTYPE html>
<html>

<head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# article: http://ogp.me/ns/article#">
<meta charset="utf-8" />
<meta http-equiv='X-UA-Compatible' content='IE=edge'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0'>
<title>Khoa học dữ liệu</title>
<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
<!-- Style for main home page -->
<link rel="stylesheet" href="/assets/css/styles.css">
<link rel="stylesheet" href="/assets/css/styles_toc.css">
<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
<script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script> 
<link href="https://fonts.googleapis.com/css?family=Open+Sans+Condensed:300" rel="stylesheet">
<!-- <link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet"> -->
<link href="https://fonts.googleapis.com/css?family=Roboto|Source+Sans+Pro" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Ubuntu" rel="stylesheet">
<link href="https://fonts.googleapis.com/css?family=Fira+Sans" rel="stylesheet">
<link rel="icon" type="image/jpg" href="assets/images/logo.jpg" sizes="32x32">
<link rel="canonical" href="https://phamdinhkhanh.github.io"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta name="author" content="Phạm Đình Khánh" />
<meta property="og:title" content="" />
<meta property="og:site_name" content="Khanh's blog" />
<meta property="og:url" content="https://phamdinhkhanh.github.io" />
<meta property="og:description" content="" />

<meta property="og:type" content="article" />
<meta property="article:published_time" content="" />


<meta property="article:author" content="Khanh" />
<meta property="article:section" content="" />

<link rel="alternate" type="application/atom+xml" title="Khanh's blog - Atom feed" href="/feed.xml" />
<style>
	
</style>
<!-- -- Import latext  -->
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
	skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
	inlineMath: [['$','$']]
  }
});
</script>

<!-- Google Analytics -->

<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-89509207-1', 'auto');
// ga('send', 'pageview');
ga('send', 'pageview', {
'page': '/',
'title': ''
});
</script>


<!-- Google Tag Manager -->
<script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-KTCD8BX');</script>
<!-- End Google Tag Manager -->
</head>
<style>
body {
  padding: 0 7.5%;
}
</style>

<body>
	<div id="fb-root"></div>
	<!-- <script>(function(d, s, id) { -->
	  <!-- var js, fjs = d.getElementsByTagName(s)[0]; -->
	  <!-- if (d.getElementById(id)) return; -->
	  <!-- js = d.createElement(s); js.id = id; -->
	  <!-- js.src = "//connect.facebook.net/en_US/sdk.js#xfbml=1&version=v2.9"; -->
	  <!-- fjs.parentNode.insertBefore(js, fjs); -->
	<!-- }(document, 'script', 'facebook-jssdk'));</script> -->
	<br>
	<div content = "container">
		<div class="row">
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/img.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Latest</div>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/06/04/PhoBERT_Fairseq.html">Bài 39 - Thực hành ứng dụng BERT</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/31/CNNHistory.html">Bài 38 - Các kiến trúc CNN hiện đại</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/28/TransformerThemDauTV.html">Bài 37 - Transformer thêm dấu Tiếng Việt</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/23/BERTModel.html">Bài 36 - BERT model</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/05/05/MultitaskLearning_MultiBranch.html">Bài 35 - Multitask Learning - Multi Branch</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/22/MultitaskLearning.html">Bài 34 - Multitask Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/15/TransferLearning.html">Bài 33 - Phương pháp Transfer Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/09/TensorflowDataset.html">Bài 32 - Kĩ thuật tensorflow Dataset</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/04/03/AWS.html">Bài 31 - Amazon Virtual Machine Deep Learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/28/deployTensorflowJS.html">Bài 30 - Xây dựng Web AI trên tensorflow js</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/23/FlaskRestAPI.html">Bài 29 - Xây dựng Flask API cho mô hình deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/21/faceNet.html">Bài 28 - Thực hành training Facenet</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/12/faceNetAlgorithm.html">Bài 27 - Mô hình Facenet trong face recognition</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/10/DarknetGoogleColab.html">Bài 26 - Huấn luyện YOLO darknet trên google colab</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/03/09/DarknetAlgorithm.html">Bài 25 - YOLO You Only Look Once</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/17/ImbalancedData.html">Bài 24 - Mất cân bằng dữ liệu (imbalanced dataset)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/02/11/NARSyscom2015.html">Bài 23 - Neural Attentive Session-Based Recommendation</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/17/ScoreCard.html">Bài 22 - Scorecard model</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2020/01/06/ImagePreprocessing.html">Bài 21 - Tiền xử lý ảnh OpenCV</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/26/Sorfmax_Recommendation_Neural_Network.html">Bài 20 - Recommendation Neural Network</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/12/ARIMAmodel.html">Bài 19 - Mô hình ARIMA trong time series</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/12/02/DeepLearningLayer.html">Bài 18 - Các layers quan trọng trong deep learning</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/22/HOG.html">Bài 17 - Thuật toán HOG (Histrogram of oriented gradient)</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/08/RFMModel.html">Bài 16 - Model RFM phân khúc khách hàng</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/11/04/Recommendation_Compound_Part1.html">Bài 15 - collaborative và content-based filtering</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/22/googleHeatmap.html">Bài 14 - Biểu đồ trên Google Map</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/10/05/SSDModelObjectDetection.html">Bài 13 - Model SSD trong Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/29/OverviewObjectDetection.html">Bài 12 - Các thuật toán Object Detection</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/16/VisualizationPython.html">Bài 11 - Visualization trong python</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/09/08/LDATopicModel.html">Bài 10 - Thuật toán LDA - Xác định Topic</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/25/PyTorch_Torchtext_Tutorial.html">Bài 9 - Pytorch - Buổi 3 - torchtext module NLP</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/22/convolutional-neural-network.html">Bài 8 - Convolutional Neural Network</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/19/CorrectSpellingVietnamseTonePrediction.html">Bài 7 - Pytorch - Buổi 2 - Seq2seq model correct spelling</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/08/10/PytorchTurtorial1.html">Bài 6 - Pytorch - Buổi 1 - Làm quen với pytorch</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/07/15/PySparkSQL.html">Bài 5 - Model Pipeline - SparkSQL</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/06/18/AttentionLayer.html">Bài 4 -  Attention is all you need</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/05/10/Hypothesis_Statistic.html">Apenddix 1 - Lý thuyết phân phối và kiểm định thống kê</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/29/ModelWord2Vec.html">Bài 3 - Mô hình Word2Vec</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/04/22/Ly_thuyet_ve_mang_LSTM.html">Bài 2 - Lý thuyết về mạng LSTM part 2</a></li>
					
					<li><a style="text-align: left; color: #074B80"  href="/2019/01/07/Ky_thuat_feature_engineering.html">Bài 1 - Kĩ thuật feature engineering</a></li>
					
				</nav>
			</div>
			<div class="col-md-8 col-xs-12" style="z-index:1">
				<nav class="navbar navbar-inverse" style="background-color: #046897">
					<div class = "container-fluid">
						<div class = "navbar-header>
							<button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#myNavbar">
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
								<span class="icon-bar"></span>
							</button>
							<a class="navbar-brand" href="/">
								<span style="color:#FFF">Khoa học dữ liệu - Khanh's blog</span>
							</a>
						</div>
						<br>
						<br>
						<div class="collapse navbar-collapse navbar-right" id="myNavbar">
							<ul class="nav navbar-nav">
								<li><a href="/home"><span style="color: #fff"> Home</span></a></li>
								<li><a href="/about"><span style="color: #fff"> About</span></a></li>
								<!-- <li><a href="/da"><span style="color: #fff">Data Analytics</span></a></li> -->
								<!-- <li><a href="/cv"><span style="color: #fff">Computer Vision</span></a></li> -->
								<!-- <li><a href="/nlp"><span style="color: #fff">NLP</span></a></li> -->
								<!-- <li><a href="/code"><span style="color: #fff">Code</span></a></li> -->
								<li><a href="/book"><span style="color: #fff">Book</span></a></li>
							</ul>
						</div>
					</div>
				</nav>
				<div class="PageNavigation">
				</div>
				<h1 itemprop="name" class="post-title"></h1>
				<div id="bootstrap-overrides">
					<div>
<h2><p class="post-link" style="text-align: left; color: #204081; font-weight: bold">Bài 18 - Các layers quan trọng trong deep learning</p></h2> 
<strong>02 Dec 2019 - phamdinhkhanh</strong>
</div>
<br/>
<div id="toc"></div>
<h1 id="1-giới-thiệu-chung">1. Giới thiệu chung</h1>

<p>Mỗi một mô hình deep learning đều có các layers đặc trưng giúp giải quyết các tác vụ cụ thể của từng bài toán deep learning. Chẳng hạn như trong xử lý ảnh chúng ta thường sử dụng mạng <a href="https://www.kaggle.com/phamdinhkhanh/convolutional-neural-network-p1">CNN - convolutional neural network</a> để trích xuất đặc trưng trên các local regional của bức ảnh là các đường nét chính như dọc, ngang, chéo,…. Hoặc layer <a href="https://phamdinhkhanh.github.io/2019/04/22/Ly_thuyet_ve_mang_LSTM.html">LSTM - long short term memory</a> được sử dụng trong các mô hình dịch máy và mô hình phân loại cảm xúc văn bản (sentiment analysis). Tuy nhiên ngoài các layer trên, chúng ta sẽ còn làm quen với rất nhiều các layers khác trong các bài toán về deep learning. Việc hiểu được công dụng của từng layer cũng như trường hợp áp dụng để mang lại hiệu quả cho mô hình rất quan trọng. Chính vì thế bài viết này nhằm mục đích hệ thống lại các layers quan trọng của deep learning như một tài liệu cheat sheet (tài liệu sổ tay) để sử dụng khi cần.</p>

<p>Do các layer CNN và LSTM đã được trình bày ở 2 bài viết của blog nên tôi sẽ không nêu lại kiến thức của những layers này. Và tất nhiên đó là những layers rất quan trọng mà bạn đọc cần nắm vững để áp dụng trong các mô hình về xử lý ảnh và ngôn ngữ. Bài viết này chỉ hướng tới những layer khác quan trọng hơn.</p>

<h1 id="2-các-layer-cơ-bản">2. Các layer cơ bản</h1>
<h2 id="21-time-distributed">2.1. Time distributed</h2>

<p>Dường như cái tên của layer này đã nói lên ý nghĩa của nó là xác định phân phối của dữ liệu theo thời gian.</p>

<p>Để hiểu rõ hơn chúng ta cùng lấy ví dụ về dự báo dạng chuỗi thông qua mạng RNN. Nhưng khoan khoan, để hiểu những gì tôi sắp viết vui lòng hiểu kĩ kiến trúc mạng RNN thông qua bài <a href="https://phamdinhkhanh.github.io/2019/04/22/Ly_thuyet_ve_mang_LSTM.html">LSTM - long short term memory</a>.</p>

<p>Bạn đã đọc xong và nắm vững kiến thức về LSTM rồi chứ? Nếu chắc chắn, chúng ta hãy tiếp tục nào. Bên dưới là những dạng dự báo của RNN:</p>

<p><img src="/assets/images/20191202_DLLayer/rnn_type.jpg" width="800px" height="200px" style="display:block; margin-left:auto; margin-right:auto" /></p>

<blockquote>
  <p><strong>Hình 1:</strong> Các dạng dự báo trong RNN</p>
</blockquote>

<ul>
  <li>One to one: Là trường hợp chỉ có 1 input và trả ra kết quả 1 output.</li>
  <li>One to many: Là trường hợp đầu vào chỉ có 1 input. Véc tơ context ở bước liền sau $t+1$ và kết hợp với output dự báo ở bước $t$ sẽ được sử dụng để dự báo được output ở bước $t+1$. Cử tiếp tục quá trình đến hết chuỗi, từ 1 input ta dự báo được một chuỗi nhiều outputs.</li>
  <li>Many to one: Là trường hợp ta chỉ trả ra kết quả là véc tơ output tại time step cuối cùng trong mạng LSTM (tương đương với cấu hình return_sequence = False trong LSTM layer của keras).</li>
  <li>Many to many: Đây chính là kiến trúc đặc trưng của model dịch máy. Tại mỗi bước thời gian $t$, input là véc tơ embedding một từ của ngôn ngữ nguồn và trả kết quả đầu ra là một véc tơ phân phối xác suất của từ output ở ngôn ngữ đích.</li>
</ul>

<p>Trong các bài toán về NLP, Khi áp dụng họ các layer RNN thì chúng ta thường có 2 lựa chọn đó là:</p>

<p>Lựa chọn 1: trả ra chỉ kết quả là hidden layer ở véc tơ cuối cùng hoặc</p>

<p>Lựa chọn 2: trả ra chuỗi các hidden véc tơ ở mỗi time step.</p>

<p>Theo sau đó, các layers tiếp theo là những fully connected layers có kiến trúc như một mạng MLP thông thường. Kết quả trả ra là dự báo phân phối xác suất nhãn. Câu hỏi được đặt ra là ta sẽ áp dụng các fully connected layers như thế nào cho từng lựa chọn? Rõ ràng đối với lựa chọn 1 thì do đầu ra của LSTM layer là một véc tơ nên ta dễ dàng truyền qua một Dense Layer (hay còn gọi là fully connected layer) thông thường và xây dựng một chuỗi fully connected layers khá dễ dàng. Tuy nhiên đối với lựa chọn 2 làm thế nào ta có thể kết hợp một Dense Layer với một chuỗi các hidden véc tơ như output của trường hợp <code class="highlighter-rouge">many to many</code> và <code class="highlighter-rouge">one to many</code> mà các bạn thấy. Khi đó chúng ta cần một layer đặc biệt hơn, không chỉ có tác dụng như dense layer trong mạng MLP mà còn có tác dụng kết nối tới từng hidden véc tơ ở mỗi bước thời gian, đó chính là Time Distributed Layers. Để dễ hình dung hơn bạn đọc có thể xem hình so sánh bên dưới giữa Time Distributed Layer và Dense Layer.</p>

<p><img src="/assets/images/20191202_DLLayer/TimeDistributed.png" width="800px" height="500px" style="display:block; margin-left:auto; margin-right:auto" /></p>

<blockquote>
  <p><strong>Hình 2:</strong> Time Distributed Layer ở bên trái kết nối chung các hidden véc tơ ở mỗi bước thời gian từ $h_0$ đến $h_{30}$ tới cùng một dense layer. Trong khi ở hình bên phải, đầu vào của dense layer chính là véc tơ cuối cùng $h_{30}$.</p>
</blockquote>

<p>Như vậy về bản chất Time Distributed Layer không khác gì một Dense Layer thông thường. Chính vì vậy trong một issue <a href="https://github.com/keras-team/keras/issues/1029">When and How to use TimeDistributedDense</a> fchollet tác giả của keras (và rất nhiều các đầu sách về deep learning trên cả python và R) đã giải thích một cách ngắn gọn như khá khó hiểu đối với beginers:</p>

<p><code class="highlighter-rouge">TimeDistributedDense applies a same Dense (fully-connected) operation to every timestep of a 3D tensor.</code></p>

<p>Ngoài ra Time Distributed Layer còn được sử dụng rất nhiều trong các mô hình xử lý video. Giả định rằng đầu vào của bạn là những batch video gồm các 5 chiều: <code class="highlighter-rouge">(batch_size, time, width, height, channels)</code>. Như vậy để áp dụng một mạng tích chập 2 chiều lên toàn bộ các khung hình theo thời gian chúng ta cần sử dụng Time Distributed để thu được output shape mới ở đầu ra gồm 4 chiều: <code class="highlighter-rouge">(batch_size, new_width, new_height, output_channels)</code>.</p>

<p>Như vậy bạn đọc đã hình dung ra nguyên lý hoạt động của Time Distributed Layer rồi chứ? Để hiểu thêm cách thức sử dụng trên keras, bạn đọc có thể tham khảo tài liệu <a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/TimeDistributed">Time Distributed Layer - keras document</a>.</p>

<p>Bên dưới chúng ta sẽ cùng đi xây dựng 2 lớp model phân loại mail rác sử dụng 2 phương pháp khác nhau là <code class="highlighter-rouge">LSTM + Dense Layer</code> và <code class="highlighter-rouge">LSTM + Time Distributed Layer</code> và đối chiếu kết quả thu được.</p>

<p>Dữ liệu được sử dụng là <a href="https://www.kaggle.com/uciml/sms-spam-collection-dataset">sms spam collection dataset</a> gồm 5574 emails tiếng anh đã được gán nhãn sẵn là các email spam (email rác)/ham (email hợp lệ). Để xây dựng model chúng ta sẽ đi qua các bước như sau:</p>

<p><strong>Bước 1:</strong> Xử lý dữ liệu.</p>

<p>Tại bước này chúng ta sẽ cần đọc và khảo sát dữ liệu để kiểm tra tính cân bằng, loại bỏ các từ stop words, dấu câu, kí tự đặc biệt và tạo từ điển để mã hóa các từ sang index.</p>

<p>Tất cả các công việc này được thực hiện khá dễ dàng nhờ những module có sẵn của <code class="highlighter-rouge">gensim</code> và <code class="highlighter-rouge">keras</code>.</p>

<ul>
  <li>Đọc và khảo sát dữ liệu:</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre></td><td class="rouge-code"><pre>import pandas as pd
dataset = pd.read_csv('spam.csv', header=0, sep=',',encoding='latin-1')
dataset = dataset.iloc[:, :2]
dataset.columns = ['Label', 'Email']
dataset.head()
</pre></td></tr></tbody></table></code></pre></div></div>

<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Label</th>
      <th>Email</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>ham</td>
      <td>Go until jurong point, crazy.. Available only ...</td>
    </tr>
    <tr>
      <th>1</th>
      <td>ham</td>
      <td>Ok lar... Joking wif u oni...</td>
    </tr>
    <tr>
      <th>2</th>
      <td>spam</td>
      <td>Free entry in 2 a wkly comp to win FA Cup fina...</td>
    </tr>
    <tr>
      <th>3</th>
      <td>ham</td>
      <td>U dun say so early hor... U c already then say...</td>
    </tr>
    <tr>
      <th>4</th>
      <td>ham</td>
      <td>Nah I don't think he goes to usf, he lives aro...</td>
    </tr>
  </tbody>
</table>
</div>

<p>Đồ thị phân phối các classes:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre></td><td class="rouge-code"><pre>dataset.groupby('Label').Email.count().plot.bar()
</pre></td></tr></tbody></table></code></pre></div></div>
<p><img src="/assets/images/20191202_DLLayer/DeepLearningLayer_4_1.png" width="400px" height="400px" style="display:block; margin-left:auto; margin-right:auto" /></p>

<ul>
  <li>Làm sạch dữ liệu bằng cách chuẩn hóa các từ viết hoa thành viết thường, loại bỏ dấu câu, loại bỏ chữ số, tách số dính liền với từ và loại bỏ stop words,… thông qua package gensim.</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre></td><td class="rouge-code"><pre>import gensim
from gensim.parsing.preprocessing import strip_non_alphanum, strip_multiple_whitespaces, preprocess_string, split_alphanum, strip_short, strip_numeric
import re 
import nltk
from nltk.corpus import stopwords
nltk.download('stopwords')
stop_words = stopwords.words('english')

# Chuyển chữ hoa sang chữ thường
def lower_case(docs):
  return [doc.lower() for doc in docs]

# Loại bỏ các dẫu câu và kí tự đặc biệt
def remove_punc(docs):
  return [strip_non_alphanum(doc).strip() for doc in docs]

# Tách các số và chữ liền nhau
def separate_num(docs):
  return [split_alphanum(doc) for doc in docs]

# Loại bỏ những từ gồm 1 chữ cái đứng đơn lẻ
def remove_one_letter_word(docs):
  return [strip_short(doc) for doc in docs]

# Loại bỏ các con số trong văn bản vì chúng không có nhiều ý nghĩa trong phân loại các từ
def remove_number(docs):
  return [strip_numeric(doc) for doc in docs]

# Thay thế nhiều khoảng spaces bằng 1 khoảng space
def replace_multiple_whitespaces(docs):
  return [strip_multiple_whitespaces(doc) for doc in docs]

# Loại bỏ các stop words
def remove_stopwords(docs):
    return [[word for word in doc.split() if word not in stop_words] for doc in docs]

docs = lower_case(dataset['Email'])
docs = remove_punc(docs)
docs = separate_num(docs)
docs = remove_one_letter_word(docs)
docs = remove_number(docs)
docs = replace_multiple_whitespaces(docs)
docs = remove_stopwords(docs)
dataset['Content_Clean'] = docs
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>Khởi tạo tokenizer để mã hóa các email.</li>
</ul>

<p>Để chuyển các câu văn thành ma trận số, chúng ta cần tạo ra một từ điển mapping mỗi từ với index tương ứng của nó. module tokenizer dễ dàng giúp ta thực hiện việc này.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="rouge-code"><pre>from tensorflow.keras.preprocessing.text import Tokenizer
from tensorflow.keras.preprocessing import sequence

def _tokenize_matrix(docs, max_words=1000, max_len=150):
  #max_words: Số lượng từ lớn nhất xuất hiện trong tokenizer được lấy từ tần suất xuất hiện trong văn bản từ cao xuống thấp.
  #max_len: Số lượng các từ lớn nhất trong một câu văn.
  #docs: Tợp hợp các đoạn email.
  tok = Tokenizer(num_words=max_words)
  tok.fit_on_texts(docs)
  X_tok =  tok.texts_to_sequences(docs)
  X = sequence.pad_sequences(X_tok, maxlen=max_len)
  return X_tok, X, tok

X_tok, X, tok = _tokenize_matrix(docs=dataset['Content_Clean'], max_words=1000, max_len=150)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Mã hóa nhãn spam/ham về biến one-hot.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>from sklearn.preprocessing import LabelEncoder
le = LabelEncoder()
y = le.fit_transform(dataset['Label'])
</pre></td></tr></tbody></table></code></pre></div></div>

<p><strong>Bước 2:</strong> Xây dựng model LSTM</p>

<p>Sau khi đã preprocessing dữ liệu, chúng ta thu được đầu vào là các ma trận padding $X$ mà các dòng của nó là những câu văn có độ dài bằng nhau. Từ ma trận padding, ta cần đi qua một layer embedding để tạo véc tơ nhúng cho mỗi từ trong câu, và sau đó đi vào mạng LSTM. Chúng ta sẽ áp dụng cả 2 kiến trúc mô hình là Dense Layer và Time Distributed Layer.</p>

<ul>
  <li>Khởi tạo model Dense Layer</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre></td><td class="rouge-code"><pre><span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span> <span class="n">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Embedding</span><span class="p">,</span> <span class="n">LSTM</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Activation</span><span class="p">,</span> <span class="n">Dropout</span><span class="p">,</span> <span class="n">TimeDistributed</span><span class="p">,</span> <span class="n">Flatten</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span> <span class="n">import</span> <span class="k">Model</span><span class="p">,</span> <span class="n">Sequential</span>
<span class="k">from</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">preprocessing</span> <span class="n">import</span> <span class="n">LabelEncoder</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span> <span class="n">import</span> <span class="n">RMSprop</span><span class="p">,</span> <span class="n">Adam</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">utils</span> <span class="n">import</span> <span class="n">to_categorical</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">callbacks</span> <span class="n">import</span> <span class="n">EarlyStopping</span>

<span class="n">def</span> <span class="n">RNN_Dense</span><span class="p">(</span><span class="n">maxword</span><span class="p">=</span><span class="m">1000</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">=</span><span class="m">100</span><span class="p">,</span> <span class="n">max_len</span><span class="p">=</span><span class="m">150</span><span class="p">,</span> <span class="n">n_unit_lstm</span><span class="p">=</span><span class="m">64</span><span class="p">,</span> <span class="n">n_unit_dense</span><span class="p">=</span><span class="m">64</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">name</span><span class="p">=</span><span class="s1">'inputs'</span><span class="p">,</span> <span class="n">shape</span><span class="p">=[</span><span class="n">max_len</span><span class="p">])</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">maxword</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">,</span> <span class="n">input_length</span><span class="p">=</span><span class="n">max_len</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="p">#</span> <span class="n">Embedding</span> <span class="p">(</span><span class="n">input_dim</span><span class="p">:</span> <span class="n">size</span> <span class="k">of</span> <span class="n">vocabolary</span><span class="p">,</span> 
    <span class="p">#</span> <span class="n">output_dim</span><span class="p">:</span> <span class="n">dimension</span> <span class="k">of</span> <span class="n">dense</span> <span class="n">embedding</span><span class="p">,</span> 
    <span class="p">#</span> <span class="n">input_length</span><span class="p">:</span> <span class="n">length</span> <span class="k">of</span> <span class="n">input</span> <span class="n">sequence</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="n">n_unit_lstm</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">n_unit_dense</span><span class="p">,</span> <span class="n">name</span><span class="p">=</span><span class="s1">'FC1'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="m">0.5</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">name</span><span class="p">=</span><span class="s1">'out_layer'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'sigmoid'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">=</span><span class="n">inputs</span><span class="p">,</span><span class="n">outputs</span><span class="p">=</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">return</span> <span class="k">model</span>

<span class="n">lstm_dense</span><span class="p">=</span><span class="n">RNN_Dense</span><span class="p">()</span>
<span class="n">lstm_dense</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
<span class="n">lstm_dense</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">loss</span><span class="p">=</span><span class="s1">'binary_crossentropy'</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">=</span><span class="n">Adam</span><span class="p">(),</span> <span class="n">metrics</span><span class="p">=[</span><span class="s1">'accuracy'</span><span class="p">])</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="rouge-code"><pre>Model: "model_14"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
inputs (InputLayer)          [(None, 150)]             0         
_________________________________________________________________
embedding_20 (Embedding)     (None, 150, 100)          100000    
_________________________________________________________________
lstm_20 (LSTM)               (None, 64)                42240     
_________________________________________________________________
FC1 (Dense)                  (None, 256)               16640     
_________________________________________________________________
activation_29 (Activation)   (None, 256)               0         
_________________________________________________________________
dropout_14 (Dropout)         (None, 256)               0         
_________________________________________________________________
out_layer (Dense)            (None, 1)                 257       
_________________________________________________________________
activation_30 (Activation)   (None, 1)                 0         
=================================================================
Total params: 159,137
Trainable params: 159,137
Non-trainable params: 0
_________________________________________________________________
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>Huấn luyện model dense</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>lstm_dense.fit(X, y, batch_size=128,
               epochs=10,
               validation_split=0.2,
               callbacks=[EarlyStopping(monitor='val_loss',min_delta=0.0001)])
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>Train on 4457 samples, validate on 1115 samples
Epoch 1/10
4457/4457 [==============================] - 13s 3ms/sample - loss: 0.4479 - acc: 0.8548 - val_loss: 0.2716 - val_acc: 0.8700
Epoch 2/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.2328 - acc: 0.9028 - val_loss: 0.1813 - val_acc: 0.9247
...
Epoch 9/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.1474 - acc: 0.9462 - val_loss: 0.1279 - val_acc: 0.9570
Epoch 10/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.1466 - acc: 0.9462 - val_loss: 0.1237 - val_acc: 0.9543
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>Khởi tạo model TimeDistributed Layer</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre><span class="n">def</span> <span class="n">RNN_TimeDis</span><span class="p">(</span><span class="n">maxword</span><span class="p">=</span><span class="m">1000</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">=</span><span class="m">100</span><span class="p">,</span> <span class="n">max_len</span><span class="p">=</span><span class="m">150</span><span class="p">,</span> <span class="n">n_unit_lstm</span><span class="p">=</span><span class="m">64</span><span class="p">,</span> <span class="n">n_unit_dense</span><span class="p">=</span><span class="m">64</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">name</span><span class="p">=</span><span class="s1">'inputs'</span><span class="p">,</span> <span class="n">shape</span><span class="p">=[</span><span class="n">max_len</span><span class="p">])</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">maxword</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">,</span> <span class="n">input_length</span><span class="p">=</span><span class="n">max_len</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="p">#</span> <span class="n">Embedding</span> <span class="p">(</span><span class="n">input_dim</span><span class="p">:</span> <span class="n">size</span> <span class="k">of</span> <span class="n">vocabolary</span><span class="p">,</span> 
    <span class="p">#</span> <span class="n">output_dim</span><span class="p">:</span> <span class="n">dimension</span> <span class="k">of</span> <span class="n">dense</span> <span class="n">embedding</span><span class="p">,</span> 
    <span class="p">#</span> <span class="n">input_length</span><span class="p">:</span> <span class="n">length</span> <span class="k">of</span> <span class="n">input</span> <span class="n">sequence</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="n">n_unit_lstm</span><span class="p">,</span> <span class="n">return_sequences</span><span class="p">=</span><span class="nb">True</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">TimeDistributed</span><span class="p">(</span><span class="n">Dense</span><span class="p">(</span><span class="n">n_unit_dense</span><span class="p">))(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Flatten</span><span class="p">()(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="m">0.5</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">name</span><span class="p">=</span><span class="s1">'out_layer'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'sigmoid'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">=</span><span class="n">inputs</span><span class="p">,</span><span class="n">outputs</span><span class="p">=</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">return</span> <span class="k">model</span>

<span class="n">lstm_timedis</span><span class="p">=</span><span class="n">RNN_TimeDis</span><span class="p">()</span>
<span class="n">lstm_timedis</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
<span class="n">lstm_timedis</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">loss</span><span class="p">=</span><span class="s1">'binary_crossentropy'</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">=</span><span class="n">Adam</span><span class="p">(),</span> <span class="n">metrics</span><span class="p">=[</span><span class="s1">'accuracy'</span><span class="p">])</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre>Model: "model_15"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
inputs (InputLayer)          [(None, 150)]             0         
_________________________________________________________________
embedding_22 (Embedding)     (None, 150, 100)          100000    
_________________________________________________________________
lstm_22 (LSTM)               (None, 150, 64)           42240     
_________________________________________________________________
time_distributed_3 (TimeDist (None, 150, 64)           4160      
_________________________________________________________________
flatten_1 (Flatten)          (None, 9600)              0         
_________________________________________________________________
activation_31 (Activation)   (None, 9600)              0         
_________________________________________________________________
dropout_15 (Dropout)         (None, 9600)              0         
_________________________________________________________________
out_layer (Dense)            (None, 1)                 9601      
_________________________________________________________________
activation_32 (Activation)   (None, 1)                 0         
=================================================================
Total params: 156,001
Trainable params: 156,001
Non-trainable params: 0
_________________________________________________________________
</pre></td></tr></tbody></table></code></pre></div></div>

<ul>
  <li>Huấn luyện model Time Distributed Layer</li>
</ul>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>lstm_timedis.fit(X, y, batch_size=128,
               epochs=10,
               validation_split=0.2,
               callbacks=[EarlyStopping(monitor='val_loss',min_delta=0.0001)])
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre>Train on 4457 samples, validate on 1115 samples
Epoch 1/10
4457/4457 [==============================] - 13s 3ms/sample - loss: 0.1701 - acc: 0.9365 - val_loss: 0.1452 - val_acc: 0.9471
Epoch 2/10
4457/4457 [==============================] - 13s 3ms/sample - loss: 0.1617 - acc: 0.9430 - val_loss: 0.1414 - val_acc: 0.9516
Epoch 3/10
4457/4457 [==============================] - 13s 3ms/sample - loss: 0.1586 - acc: 0.9430 - val_loss: 0.1401 - val_acc: 0.9534
Epoch 4/10
4457/4457 [==============================] - 13s 3ms/sample - loss: 0.1554 - acc: 0.9435 - val_loss: 0.1381 - val_acc: 0.9507
Epoch 5/10
4457/4457 [==============================] - 13s 3ms/sample - loss: 0.1599 - acc: 0.9444 - val_loss: 0.1345 - val_acc: 0.9525
Epoch 6/10
4457/4457 [==============================] - 13s 3ms/sample - loss: 0.1438 - acc: 0.9484 - val_loss: 0.1366 - val_acc: 0.9516
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Kết quả cho thấy model áp dụng Time Distributed và áp dụng Dense đều khá tốt. Mức độ chính xác thu được trên tập validation đều trên 95%.</p>

<p>Ngoải ra thì Time Distributed còn được áp dụng trong phân loại nội dung video rất hiệu quả. Có thời gian tôi sẽ hướng dẫn các bạn.</p>

<h2 id="22-batch-normalization">2.2. Batch Normalization</h2>

<p>Nếu bạn đã làm quen với các kiến trúc mô hình trong CNN như Alexnet, VGG16, VGG19 thì batch normalization là một layer được sử dụng khá nhiều. Layer này thường áp dụng ngay sau Convolutional layer và thường ở những vị trí đầu tiên của mô hình để đạt hiệu quả cao nhất. Mục đích chính của batch normalization đó là chuẩn hóa dữ liệu ở các layer theo batch về phân phối chuẩn để quá trình gradient descent hội tụ nhanh hơn.</p>

<p>Gỉa sử chúng ta có một mini-batch với giá trị của từng quan sát trong batch như sau: $\mathcal{B} = {x_1, x_2, \dots, x_m}$ Khi đó Batch Normalization sẽ được xác định thông qua phép chuẩn hóa trung bình và phương sai của các phần tử trong batch theo công thức bên dưới:</p>

<p>$\mu = \frac{1}{m} \sum_{i=1}^{m} x_i$</p>

<p>$\sigma^2 = \frac{1}{m}\sum_{i=1}^{m}(x_i-\mu)^2$</p>

<p>$\hat{x_i} = \frac{x_i-\mu}{\sqrt{\sigma^2+\epsilon}}$</p>

<p>giá trị $\hat{x_i}$ chính là kết quả sau chuẩn hóa.</p>

<p>Để hiểu hơn về cách áp dụng và hiệu quả của batch normalization, chúng ta sẽ thử nghiệm xây dựng mô hình LeNet có sử dụng batch normalization và không sử dụng batch normalization và so sánh kết quả mô hình sau huấn luyện. Bộ dữ liệu mà chúng ta sử dụng là mnist gồm các bức ảnh kích thước 28 x 28 của 10 chữ số từ 0 đến 9. Thật may mắn là dữ liệu này có thể load trực tiếp từ keras, rất tiện lợi.</p>

<p><strong>Bước 1:</strong> Load dữ liệu từ keras.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre></td><td class="rouge-code"><pre># Load dữ liệu.
from tensorflow.examples.tutorials.mnist import input_data
import tensorflow as tf
from tensorflow import keras
print(tf.__version__)

# mnist = keras.datasets.mnist
# (X_train, y_train), (X_test, y_test) = mnist.load_data() 

mnist = input_data.read_data_sets("MNIST_data/", reshape=False)
X_train, y_train = mnist.train.images, mnist.train.labels
X_val, y_val = mnist.validation.images, mnist.validation.labels
X_test, y_test = mnist.test.images, mnist.test.labels
print('X_train shape: {}'.format(X_train.shape))
print('y_train shape: {}'.format(y_train.shape))
print('X_test shape: {}'.format(X_test.shape))
print('y_test shape: {}'.format(y_test.shape))
print('X_val shape: {}'.format(X_val.shape))
print('y_val shape: {}'.format(y_val.shape))
</pre></td></tr></tbody></table></code></pre></div></div>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre>X_train shape: (55000, 28, 28, 1)
y_train shape: (55000,)
X_test shape: (10000, 28, 28, 1)
y_test shape: (10000,)
X_val shape: (5000, 28, 28, 1)
y_val shape: (5000,)
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Bước tiếp theo tuy đơn giản nhưng vô cùng quan trọng. Rất nhiều beginer thường bỏ qua vì chưa có kinh nghiệm. Đó là kiểm tra phân phối số quan sát trên các nhóm.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre></td><td class="rouge-code"><pre>import matplotlib.pyplot as plt
import numpy as np

# Thống kê số lượng ở mỗi classes
def _plot_bar(x, title = 'Number observations of each class'):
  x, y = np.unique(x, return_counts=True)
  x_lab = [str(lab) for lab in x]
  plt.bar(x_lab, y)
  plt.xlabel('Class label')
  plt.ylabel('Number observations')
  plt.title(title)
  
  for i in range(len(x)): # your number of bars
    plt.text(x = x[i]-0.5, #takes your x values as horizontal positioning argument 
    y = y[i]+1, #takes your y values as vertical positioning argument 
    s = y[i], # the labels you want to add to the data
    size = 10)

_plot_bar(y_train)
_plot_bar(y_test)
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20191202_DLLayer/DeepLearningLayer_23_0.png" width="600px" height="400px" style="display:block; margin-left:auto; margin-right:auto" /></p>

<p>Do input của mạng LeNet có kích thước <code class="highlighter-rouge">32 x 32</code> nên ta cần padding thêm các chiều để có kích thước là <code class="highlighter-rouge">32 x 32</code>. Thực hiện dễ dàng như sau:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>X_train = np.pad(X_train, ((0, 0), (2, 2), (2, 2), (0, 0)), 'constant')
X_val = np.pad(X_val, ((0, 0), (2, 2), (2, 2), (0, 0)), 'constant')
X_test = np.pad(X_test, ((0, 0), (2, 2), (2, 2), (0, 0)), 'constant')

print('X_train shape: {}'.format(X_train.shape))
print('X_test shape: {}'.format(X_test.shape))
print('X_val shape: {}'.format(X_val.shape))

# Để chắc chắn đã padding đúng thì hiển thị ra 1 hình ảnh số để kiểm tra:
plt.imshow(np.squeeze(X_train[np.random.randint(55000)], axis=2), cmap=plt.cm.binary)
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre>X_train shape: (55000, 32, 32, 1)
X_test shape: (10000, 32, 32, 1)
X_val shape: (5000, 32, 32, 1)
</pre></td></tr></tbody></table></code></pre></div></div>

<p><img src="/assets/images/20191202_DLLayer/DeepLearningLayer_25_2.png" width="200px" height="200px" style="display:block; margin-left:auto; margin-right:auto" /></p>

<p>LeNet là mạng CNN đơn giản được tạo ra vào 1998 bởi Yan LeCun khi ông áp dụng thêm các layers tích chập (Convolutional) kết hợp với MaxPooling. Trong đó layer tích chập giúp nhận diện các đường nét dọc, ngang, chéo,… của vật thể còn MaxPooling nhằm giảm chiều dữ liệu mà không thay đổi các đặc trưng của ảnh giúp nhận diện vật thể. Cụ thể về kiến trúc từng layers các bạn xem hình vẽ bên dưới.</p>

<p><img src="/assets/images/20191202_DLLayer/LeNet5.png" width="800px" height="300px" style="display:block; margin-left:auto; margin-right:auto" /></p>

<blockquote>
  <p><strong>Hình 3:</strong> Kiến trúc mạng LeNet. Trong đó input layer nhận đầu vào là những ảnh kích thước 32 x 32. Tiếp theo là 2 lượt (Convolutional 2D + Maxpooling) giúp giảm chiều dữ liệu từ 32 x 32 xuống còn 5 x 5. Flatten kết quả thành véc tơ và chuyển sang một mạng fully connected thông thường ta sẽ thu được giá trị dự báo xác suất ở output.</p>
</blockquote>

<p>Chúng ta khởi tạo model LeNet không có BatchNormalization.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre></td><td class="rouge-code"><pre><span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span> <span class="n">import</span> <span class="n">Flatten</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Activation</span><span class="p">,</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span><span class="p">,</span> <span class="n">Reshape</span><span class="p">,</span> <span class="n">BatchNormalization</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span> <span class="n">import</span> <span class="n">Adam</span><span class="p">,</span> <span class="n">SGD</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span> <span class="n">import</span> <span class="n">Sequential</span><span class="p">,</span> <span class="k">Model</span>

<span class="n">def</span> <span class="n">_Lenet_No_BatchNorm</span><span class="p">():</span>
  <span class="n">inp</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="p">=(</span><span class="m">32</span><span class="p">,</span> <span class="m">32</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
  <span class="n">conv1</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span>
      <span class="n">filters</span><span class="p">=</span><span class="m">4</span><span class="p">,</span>
      <span class="n">kernel_size</span><span class="p">=</span><span class="m">5</span><span class="p">,</span>
      <span class="n">padding</span><span class="p">=</span><span class="s1">'valid'</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">1</span><span class="p">,</span>
      <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">inp</span><span class="p">)</span>

  <span class="n">maxpool1</span> <span class="p">=</span> <span class="n">MaxPooling2D</span><span class="p">(</span>
      <span class="n">pool_size</span><span class="p">=</span><span class="m">2</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">2</span>
  <span class="p">)(</span><span class="n">conv1</span><span class="p">)</span>

  <span class="n">conv2</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span>
      <span class="n">filters</span><span class="p">=</span><span class="m">16</span><span class="p">,</span>
      <span class="n">kernel_size</span><span class="p">=</span><span class="m">5</span><span class="p">,</span>
      <span class="n">padding</span><span class="p">=</span><span class="s1">'valid'</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">1</span><span class="p">,</span>
      <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">maxpool1</span><span class="p">)</span>

  <span class="n">maxpool2</span> <span class="p">=</span> <span class="n">MaxPooling2D</span><span class="p">(</span>
      <span class="n">pool_size</span><span class="p">=</span><span class="m">2</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">2</span>
  <span class="p">)(</span><span class="n">conv2</span><span class="p">)</span>

  <span class="n">conv3</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span>
      <span class="n">filters</span><span class="p">=</span><span class="m">64</span><span class="p">,</span>
      <span class="n">kernel_size</span><span class="p">=</span><span class="m">5</span><span class="p">,</span>
      <span class="n">padding</span><span class="p">=</span><span class="s1">'valid'</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">1</span><span class="p">,</span>
      <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">maxpool2</span><span class="p">)</span>

  <span class="n">flatten</span> <span class="p">=</span> <span class="n">Flatten</span><span class="p">()(</span><span class="n">conv3</span><span class="p">)</span>
  <span class="n">dense1</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="p">=</span><span class="m">64</span><span class="p">,</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">flatten</span><span class="p">)</span>
  <span class="n">dense2</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="p">=</span><span class="m">32</span><span class="p">,</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">dense1</span><span class="p">)</span>
  <span class="n">dense3</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'sigmoid'</span><span class="p">)(</span><span class="n">dense2</span><span class="p">)</span>
  <span class="n">output</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'softmax'</span><span class="p">)(</span><span class="n">dense3</span><span class="p">)</span>
  <span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">(</span><span class="n">inputs</span> <span class="p">=</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outputs</span><span class="p">=</span><span class="n">output</span><span class="p">)</span>
  <span class="k">model</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
  <span class="n">return</span> <span class="k">model</span>

<span class="n">lenet_no_batchnorm</span> <span class="p">=</span> <span class="n">_Lenet_No_BatchNorm</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre></td><td class="rouge-code"><pre>Model: "model_17"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
input_2 (InputLayer)         [(None, 32, 32, 1)]       0         
_________________________________________________________________
conv2d_3 (Conv2D)            (None, 28, 28, 4)         104       
_________________________________________________________________
max_pooling2d_2 (MaxPooling2 (None, 14, 14, 4)         0         
_________________________________________________________________
conv2d_4 (Conv2D)            (None, 10, 10, 16)        1616      
_________________________________________________________________
max_pooling2d_3 (MaxPooling2 (None, 5, 5, 16)          0         
_________________________________________________________________
conv2d_5 (Conv2D)            (None, 1, 1, 64)          25664     
_________________________________________________________________
flatten_3 (Flatten)          (None, 64)                0         
_________________________________________________________________
dense_7 (Dense)              (None, 64)                4160      
_________________________________________________________________
dense_8 (Dense)              (None, 32)                2080      
_________________________________________________________________
dense_9 (Dense)              (None, 10)                330       
_________________________________________________________________
activation_34 (Activation)   (None, 10)                0         
=================================================================
Total params: 33,954
Trainable params: 33,954
Non-trainable params: 0
_________________________________________________________________
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Huấn luyện model LeNet khi không có Batch Normalization</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>from tensorflow.keras.callbacks import EarlyStopping
# Compile model
optimizer = Adam(learning_rate=0.005, beta_1=0.9, beta_2=0.999, amsgrad=False)
lenet_no_batchnorm.compile(loss='sparse_categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])

# Khởi tạo model checkpoint
earlyStopping = EarlyStopping(monitor='val_loss', min_delta=0.0001, patience=2, verbose=0, mode='auto', baseline=None, restore_best_weights=False)
# Huấn luyện model
lenet_no_batchnorm.fit(X_train, y_train,
              batch_size=256,
              # validation_data=[X_val, y_val],
              validation_split=0.2,
              epochs=10,
              shuffle=True,
              callbacks=[earlyStopping])
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>Train on 44000 samples, validate on 11000 samples
Epoch 1/10
44000/44000 [==============================] - 21s 479us/sample - loss: 1.5967 - acc: 0.8620 - val_loss: 1.4977 - val_acc: 0.9615
Epoch 2/10
44000/44000 [==============================] - 20s 462us/sample - loss: 1.4898 - acc: 0.9651 - val_loss: 1.4871 - val_acc: 0.9685
...
Epoch 6/10
44000/44000 [==============================] - 20s 463us/sample - loss: 1.4744 - acc: 0.9834 - val_loss: 1.4789 - val_acc: 0.9780
Epoch 7/10
44000/44000 [==============================] - 20s 465us/sample - loss: 1.4734 - acc: 0.9840 - val_loss: 1.4817 - val_acc: 0.9754
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Khởi tạo model LeNet khi có BatchNormalization</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre></td><td class="rouge-code"><pre><span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span> <span class="n">import</span> <span class="n">Flatten</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Activation</span><span class="p">,</span> <span class="n">Conv2D</span><span class="p">,</span> <span class="n">MaxPooling2D</span><span class="p">,</span> <span class="n">Reshape</span><span class="p">,</span> <span class="n">BatchNormalization</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span> <span class="n">import</span> <span class="n">Adam</span><span class="p">,</span> <span class="n">SGD</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span> <span class="n">import</span> <span class="n">Sequential</span><span class="p">,</span> <span class="k">Model</span>

<span class="n">def</span> <span class="n">_Lenet_BatchNorm</span><span class="p">():</span>
  <span class="n">inp</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">shape</span><span class="p">=(</span><span class="m">32</span><span class="p">,</span> <span class="m">32</span><span class="p">,</span> <span class="m">1</span><span class="p">))</span>
  <span class="n">conv1</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span>
      <span class="n">filters</span><span class="p">=</span><span class="m">4</span><span class="p">,</span>
      <span class="n">kernel_size</span><span class="p">=</span><span class="m">5</span><span class="p">,</span>
      <span class="n">padding</span><span class="p">=</span><span class="s1">'valid'</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">1</span><span class="p">,</span>
      <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">inp</span><span class="p">)</span>

  <span class="n">batch_norm1</span> <span class="p">=</span> <span class="n">BatchNormalization</span><span class="p">()(</span><span class="n">conv1</span><span class="p">)</span>

  <span class="n">maxpool1</span> <span class="p">=</span> <span class="n">MaxPooling2D</span><span class="p">(</span>
      <span class="n">pool_size</span><span class="p">=</span><span class="m">2</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">2</span>
  <span class="p">)(</span><span class="n">batch_norm1</span><span class="p">)</span>

  <span class="n">conv2</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span>
      <span class="n">filters</span><span class="p">=</span><span class="m">16</span><span class="p">,</span>
      <span class="n">kernel_size</span><span class="p">=</span><span class="m">5</span><span class="p">,</span>
      <span class="n">padding</span><span class="p">=</span><span class="s1">'valid'</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">1</span><span class="p">,</span>
      <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">maxpool1</span><span class="p">)</span>

  <span class="n">batch_norm2</span> <span class="p">=</span> <span class="n">BatchNormalization</span><span class="p">()(</span><span class="n">conv2</span><span class="p">)</span>

  <span class="n">maxpool2</span> <span class="p">=</span> <span class="n">MaxPooling2D</span><span class="p">(</span>
      <span class="n">pool_size</span><span class="p">=</span><span class="m">2</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">2</span>
  <span class="p">)(</span><span class="n">batch_norm2</span><span class="p">)</span>

  <span class="n">conv3</span> <span class="p">=</span> <span class="n">Conv2D</span><span class="p">(</span>
      <span class="n">filters</span><span class="p">=</span><span class="m">64</span><span class="p">,</span>
      <span class="n">kernel_size</span><span class="p">=</span><span class="m">5</span><span class="p">,</span>
      <span class="n">padding</span><span class="p">=</span><span class="s1">'valid'</span><span class="p">,</span>
      <span class="n">strides</span><span class="p">=</span><span class="m">1</span><span class="p">,</span>
      <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">maxpool2</span><span class="p">)</span>

  <span class="n">flatten</span> <span class="p">=</span> <span class="n">Flatten</span><span class="p">()(</span><span class="n">conv3</span><span class="p">)</span>
  <span class="n">dense1</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="p">=</span><span class="m">64</span><span class="p">,</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">flatten</span><span class="p">)</span>
  <span class="n">dense2</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">units</span><span class="p">=</span><span class="m">32</span><span class="p">,</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">dense1</span><span class="p">)</span>
  <span class="n">dense3</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="m">10</span><span class="p">,</span> <span class="n">activation</span><span class="p">=</span><span class="s1">'sigmoid'</span><span class="p">)(</span><span class="n">dense2</span><span class="p">)</span>
  <span class="n">output</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'softmax'</span><span class="p">)(</span><span class="n">dense3</span><span class="p">)</span>
  <span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">(</span><span class="n">inputs</span> <span class="p">=</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outputs</span><span class="p">=</span><span class="n">output</span><span class="p">)</span>
  <span class="k">model</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
  <span class="n">return</span> <span class="k">model</span>

<span class="n">lenet_batchnorm</span> <span class="p">=</span> <span class="n">_Lenet_BatchNorm</span><span class="p">()</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre></td><td class="rouge-code"><pre>Model: "model_22"
_________________________________________________________________
Layer (type)                 Output Shape              Param #   
=================================================================
input_9 (InputLayer)         [(None, 32, 32, 1)]       0         
_________________________________________________________________
conv2d_20 (Conv2D)           (None, 28, 28, 4)         104       
_________________________________________________________________
batch_normalization_6 (Batch (None, 28, 28, 4)         16        
_________________________________________________________________
max_pooling2d_14 (MaxPooling (None, 14, 14, 4)         0         
_________________________________________________________________
conv2d_21 (Conv2D)           (None, 10, 10, 16)        1616      
_________________________________________________________________
batch_normalization_7 (Batch (None, 10, 10, 16)        64        
_________________________________________________________________
max_pooling2d_15 (MaxPooling (None, 5, 5, 16)          0         
_________________________________________________________________
conv2d_22 (Conv2D)           (None, 1, 1, 64)          25664     
_________________________________________________________________
flatten_8 (Flatten)          (None, 64)                0         
_________________________________________________________________
dense_22 (Dense)             (None, 64)                4160      
_________________________________________________________________
dense_23 (Dense)             (None, 32)                2080      
_________________________________________________________________
dense_24 (Dense)             (None, 10)                330       
_________________________________________________________________
activation_39 (Activation)   (None, 10)                0         
=================================================================
Total params: 34,034
Trainable params: 33,994
Non-trainable params: 40
_________________________________________________________________
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Huấn luyện model với Batch Normalization</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="rouge-code"><pre>from tensorflow.keras.callbacks import EarlyStopping
# Compile model
optimizer = Adam(learning_rate=0.005, beta_1=0.9, beta_2=0.999, amsgrad=False)
lenet_batchnorm.compile(loss='sparse_categorical_crossentropy', optimizer=optimizer, metrics=['accuracy'])

# Khởi tạo model checkpoint
earlyStopping = EarlyStopping(monitor='val_loss', min_delta=0.0001, patience=2, verbose=0, mode='auto', baseline=None, restore_best_weights=False)
# Huấn luyện model
lenet_batchnorm.fit(X_train, y_train,
              batch_size=256,
              # validation_data=[X_val, y_val],
              validation_split=0.2,
              epochs=10,
              shuffle=True,
              callbacks=[earlyStopping])
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre>Train on 44000 samples, validate on 11000 samples
Epoch 1/10
44000/44000 [==============================] - 30s 688us/sample - loss: 1.5439 - acc: 0.9005 - val_loss: 1.9579 - val_acc: 0.4065
Epoch 2/10
44000/44000 [==============================] - 29s 659us/sample - loss: 1.4801 - acc: 0.9775 - val_loss: 1.5016 - val_acc: 0.9549
...
Epoch 6/10
44000/44000 [==============================] - 29s 654us/sample - loss: 1.4734 - acc: 0.9845 - val_loss: 1.4813 - val_acc: 0.9743
Epoch 7/10
44000/44000 [==============================] - 29s 655us/sample - loss: 1.4740 - acc: 0.9841 - val_loss: 1.4774 - val_acc: 0.9790
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Ta thấy rằng model khi áp dụng Batch Normalization có tốc độ hội tụ nhanh hơn và độ chính xác cũng đồng thời cao hơn chút so với không áp dụng Batch Normalization. Điều đó chứng tỏ cơ chế chuẩn hóa dữ liệu sau mỗi layer đã giúp cho các tham số hội tụ nhanh hơn. Một thay đổi nhỏ nhưng hiệu quả mang lại thật bất ngờ.</p>

<h2 id="23-attention-layer">2.3. Attention Layer</h2>

<p>Trong những năm gần đây, độ chính xác của các mô hình dịch máy được cải thiện một cách đáng kể, thành tựu đó đạt được chính là nhờ một layer đặc biệt có tác dụng phân bố lại trọng số attention weight của các một từ input lên từ output sao cho càng ở vị trí gần thì trọng số càng cao.</p>

<p>Cụ thể về thuật toán attention tôi sẽ không trình bày chi tiết ở đây bởi tôi đã giới thiệu ở một bài trước đó <a href="https://phamdinhkhanh.github.io/2019/06/18/AttentionLayer.html">Bài 4: Attention is all you need</a>.</p>

<p>Như đã biết về cơ chế của thuật toán RNN, chúng ta yêu cầu output véc tơ tại mỗi time step liên tục lưu trữ thông tin để dự báo từ tiếp theo, tính toán attention và encode nội dung tương ứng với các step trong tương lai. Việc sử dụng output quá tải như vậy có thể ảnh hưởng đến tốc độ và hiệu năng của mô hình. Một kiến trúc key-value(-predict) attention đã được giới thiệu bởi <a href="https://arxiv.org/abs/1702.04521.pdf">Daniluk, 2017</a> để giải quyết vấn đề trên. Kiến trúc này cho phép tách riêng ác phần tính attention và dự báo output. Cụ thể kiến trúc này như bên dưới:</p>

<p><img src="/assets/images/20191202_DLLayer/attention_key_value.png" width="800px" height="300px" style="display:block; margin-left:auto; margin-right:auto" /></p>

<blockquote>
  <p><strong>Hình 4:</strong> Sơ đồ cơ chế key-value attention. Chúng ta chia đôi hidden output véc tơ thành các cặp key-value véc tơ để giảm tải gánh nặng cho quá trình tính toán output.</p>
</blockquote>

<p>Các cặp key-value được chia ra từ output véc tơ thành 2 phần như hình (b). Công dụng của các cặp key này như sau:</p>

<ul>
  <li>phần keys chiếm một nứa hidden output được sử dụng để tính toán attention.</li>
  <li>phần value chiếm một nửa hidden output được sử dụng để giải mã phân phối của từ tiếp theo và biểu diễn của véc tơ context.</li>
</ul>

<p>Các input đầu vào của mô hình là $x$ và ta gọi đó là query.Trong một số trường hợp, ta lựa chọn giá trị của query và value là trùng nhau. Từ giá trị keys và values chúng ta tính được ra giá trị dự báo cho các bước tiếp theo và giá trị này chính là predict. Như vậy đầu ra cuối cùng của mô hình trả ra 3 véc tơ tại mỗi bước thời gian gồm: các véc tơ $v$ được dùng để giải mã phân phối của từ tiếp theo, các véc tơ $k$ được sử dụng như là key cho tính toán các attention véc tơ, véc tơ $p$ như là value cuối cùng sau khi áp dụng cơ chế attention như chúng ta nhìn thấy trong hình 4(c).</p>

<p>Hiện nay kiến trúc key-value attention layer cho kết quả và tốc độ tính toán tốt hơn so với các kiến trúc attention trước đó.</p>

<p>Trong tensorflow version 2.0.0, attention layer được khởi tạo chính là dựa trên kiến trúc key-value attention layer. Các bạn có thể tham khảo tại: <a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Attention">Attention Layer - Tensorflow</a>. Ngoài ra layer này còn cho phép sử dụng thêm các layer mask như query_mask và value_mask để loại bỏ attention tại một số vị trí nhất định trong query hoặc value.</p>

<p>Do mức độ tập trung phụ thuộc vào vị trí của từ trong câu nên attention layer được sử dụng chủ yếu ở những mô hình Seq2Seq. Ngoài ra trong các mô hình phân loại văn bản sử dụng LSTM thì attention layer cũng hoạt động khá hiệu quả.</p>

<p>Sau đây ta sẽ áp dụng Attention Layer đằng sau LSTM model trong tác vụ phân loại mail spam và so sánh hiệu quả so với áp dụng các layer như TimeDistrubted Layer và Dense Layer.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="rouge-code"><pre>from tensorflow.keras.layers import Layer, InputSpec
from tensorflow.keras import initializers

class AttLayer(Layer):
    def __init__(self, **kwargs):
        self.init = initializers.RandomNormal()
        #self.input_spec = [InputSpec(ndim=3)]
        super(AttLayer, self).__init__(**kwargs)

    def build(self, input_shape):
        assert len(input_shape)==3
        #self.W = self.init((input_shape[-1],1))
        self.W = self.init((input_shape[-1],))
        #self.input_spec = [InputSpec(shape=input_shape)]
        self.trainable_weights = [self.W]
        super(AttLayer, self).build(input_shape)  # be sure you call this somewhere!

    def call(self, x, mask=None):
        eij = K.tanh(K.dot(x, self.W))
        
        ai = K.exp(eij)
        weights = ai/K.sum(ai, axis=1).dimshuffle(0,'x')
        
        weighted_input = x*weights.dimshuffle(0,1,'x')
        return weighted_input.sum(axis=1)

    def get_output_shape_for(self, input_shape):
        return (input_shape[0], input_shape[-1])
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="rouge-code"><pre><span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">layers</span> <span class="n">import</span> <span class="n">Input</span><span class="p">,</span> <span class="n">Embedding</span><span class="p">,</span> <span class="n">LSTM</span><span class="p">,</span> <span class="n">Dense</span><span class="p">,</span> <span class="n">Activation</span><span class="p">,</span> <span class="n">Dropout</span><span class="p">,</span> <span class="n">TimeDistributed</span><span class="p">,</span> <span class="n">Flatten</span><span class="p">,</span> <span class="n">Layer</span><span class="p">,</span> <span class="n">Attention</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">models</span> <span class="n">import</span> <span class="k">Model</span><span class="p">,</span> <span class="n">Sequential</span>
<span class="k">from</span> <span class="n">sklearn</span><span class="p">.</span><span class="n">preprocessing</span> <span class="n">import</span> <span class="n">LabelEncoder</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">optimizers</span> <span class="n">import</span> <span class="n">RMSprop</span><span class="p">,</span> <span class="n">Adam</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">utils</span> <span class="n">import</span> <span class="n">to_categorical</span>
<span class="k">from</span> <span class="n">tensorflow</span><span class="p">.</span><span class="n">keras</span><span class="p">.</span><span class="n">callbacks</span> <span class="n">import</span> <span class="n">EarlyStopping</span>

<span class="n">def</span> <span class="n">RNN_AttLayer</span><span class="p">(</span><span class="n">maxword</span><span class="p">=</span><span class="m">1000</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">=</span><span class="m">100</span><span class="p">,</span> <span class="n">max_len</span><span class="p">=</span><span class="m">150</span><span class="p">,</span> <span class="n">n_unit_lstm</span><span class="p">=</span><span class="m">64</span><span class="p">,</span> <span class="n">n_unit_dense</span><span class="p">=</span><span class="m">64</span><span class="p">):</span>
    <span class="n">inputs</span> <span class="p">=</span> <span class="n">Input</span><span class="p">(</span><span class="n">name</span><span class="p">=</span><span class="s1">'inputs'</span><span class="p">,</span> <span class="n">shape</span><span class="p">=[</span><span class="n">max_len</span><span class="p">])</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Embedding</span><span class="p">(</span><span class="n">maxword</span><span class="p">,</span> <span class="n">embedding_size</span><span class="p">,</span> <span class="n">input_length</span><span class="p">=</span><span class="n">max_len</span><span class="p">)(</span><span class="n">inputs</span><span class="p">)</span>
    <span class="p">#</span> <span class="n">Embedding</span> <span class="p">(</span><span class="n">input_dim</span><span class="p">:</span> <span class="n">size</span> <span class="k">of</span> <span class="n">vocabolary</span><span class="p">,</span> 
    <span class="p">#</span> <span class="n">output_dim</span><span class="p">:</span> <span class="n">dimension</span> <span class="k">of</span> <span class="n">dense</span> <span class="n">embedding</span><span class="p">,</span> 
    <span class="p">#</span> <span class="n">input_length</span><span class="p">:</span> <span class="n">length</span> <span class="k">of</span> <span class="n">input</span> <span class="n">sequence</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">LSTM</span><span class="p">(</span><span class="n">n_unit_lstm</span><span class="p">,</span> <span class="n">return_sequences</span><span class="p">=</span><span class="nb">False</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Attention</span><span class="p">()([</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer</span><span class="p">])</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="n">n_unit_dense</span><span class="p">,</span> <span class="n">name</span><span class="p">=</span><span class="s1">'FC1'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'relu'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dropout</span><span class="p">(</span><span class="m">0.5</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Dense</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="n">name</span><span class="p">=</span><span class="s1">'out_layer'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">layer</span> <span class="p">=</span> <span class="n">Activation</span><span class="p">(</span><span class="s1">'sigmoid'</span><span class="p">)(</span><span class="n">layer</span><span class="p">)</span>
    <span class="k">model</span> <span class="p">=</span> <span class="k">Model</span><span class="p">(</span><span class="n">inputs</span><span class="p">=</span><span class="n">inputs</span><span class="p">,</span><span class="n">outputs</span><span class="p">=</span><span class="n">layer</span><span class="p">)</span>
    <span class="n">return</span> <span class="k">model</span>

<span class="n">lstm_attlayer</span><span class="p">=</span><span class="n">RNN_AttLayer</span><span class="p">()</span>
<span class="n">lstm_attlayer</span><span class="p">.</span><span class="n">summary</span><span class="p">()</span>
<span class="n">lstm_attlayer</span><span class="p">.</span><span class="nf">compile</span><span class="p">(</span><span class="n">loss</span><span class="p">=</span><span class="s1">'binary_crossentropy'</span><span class="p">,</span> <span class="n">optimizer</span><span class="p">=</span><span class="n">Adam</span><span class="p">(),</span> <span class="n">metrics</span><span class="p">=[</span><span class="s1">'accuracy'</span><span class="p">])</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre></td><td class="rouge-code"><pre>Model: "model_24"
__________________________________________________________________________________________________
Layer (type)                    Output Shape         Param #     Connected to                     
==================================================================================================
inputs (InputLayer)             [(None, 150)]        0                                            
__________________________________________________________________________________________________
embedding_28 (Embedding)        (None, 150, 100)     100000      inputs[0][0]                     
__________________________________________________________________________________________________
lstm_28 (LSTM)                  (None, 64)           42240       embedding_28[0][0]               
__________________________________________________________________________________________________
attention_2 (Attention)         (None, 64)           0           lstm_28[0][0]                    
                                                                 lstm_28[0][0]                    
__________________________________________________________________________________________________
FC1 (Dense)                     (None, 64)           4160        attention_2[0][0]                
__________________________________________________________________________________________________
activation_42 (Activation)      (None, 64)           0           FC1[0][0]                        
__________________________________________________________________________________________________
dropout_17 (Dropout)            (None, 64)           0           activation_42[0][0]              
__________________________________________________________________________________________________
out_layer (Dense)               (None, 1)            65          dropout_17[0][0]                 
__________________________________________________________________________________________________
activation_43 (Activation)      (None, 1)            0           out_layer[0][0]                  
==================================================================================================
Total params: 146,465
Trainable params: 146,465
Non-trainable params: 0
__________________________________________________________________________________________________
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="rouge-code"><pre>lstm_dense.fit(X, y, batch_size=128,
               epochs=10,
               validation_split=0.2,
               callbacks=[EarlyStopping(monitor='val_loss',min_delta=0.0001)])
</pre></td></tr></tbody></table></code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre></td><td class="rouge-code"><pre>Train on 4457 samples, validate on 1115 samples
Epoch 1/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.1402 - acc: 0.9488 - val_loss: 0.1475 - val_acc: 0.9444
Epoch 2/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.1417 - acc: 0.9491 - val_loss: 0.1214 - val_acc: 0.9570
Epoch 3/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.1354 - acc: 0.9531 - val_loss: 0.1200 - val_acc: 0.9552
Epoch 4/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.1328 - acc: 0.9520 - val_loss: 0.1156 - val_acc: 0.9596
Epoch 5/10
4457/4457 [==============================] - 12s 3ms/sample - loss: 0.1328 - acc: 0.9502 - val_loss: 0.1172 - val_acc: 0.9605
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Như vậy ta thấy rằng khi áp dụng attention layer vào mô hình phân loại email thì độ chính xác của mô hình cao hơn. Ngay từ những epoch đầu tiên mô hình đã đạt được độ chính xác dường như hoàn hảo.</p>

<p>Điều này cho thấy attention layer rất mạnh trong việc nắm bắt các liên kết dài của chuỗi các từ trong câu và khắc phục được nhược điểm về sự phụ thuộc dài hạn kém của các mô hình Recurrent Neural Network.</p>

<p>Như vậy bài này tôi đã giới thiệu đến các bạn một số layers nổi bật của Deep Learning bao gồm Time Distributed, Batch Normalization và Attention Layer bên cạnh các layers chuyên biệt cho các mô hình xử lý ảnh (CNN) và ngôn ngữ tự nhiên (LSTM, GRU, RNN, BiDirectional RNN) mà các bạn chắc chắn phải nắm vững.</p>

<p>Qua các ví dụ minh họa chúng ta cũng so sánh được một cách tương đối hiệu quả của việc áp dụng các layers này và trường hợp nào, lớp mô hình hoặc bài toán nào thì nên áp dụng.</p>

<p>Ngoài ra còn rất nhiều các layers quan trọng khác của deep learning mà tôi sẽ viết ở những bài sau nữa nếu có dịp. Hi vọng rằng các bạn có thể áp dụng tốt những layers trên vào các bài toán của mình để nâng cao hiệu quả cho mô hình.</p>

<p>Và cuối cùng không thể thiếu trong các bài viết của Khanh Blog là Tài liệu tham khảo như một sự tôn trọng và tri ân gửi tới các tác giả mà tôi đã học hỏi.</p>

<h1 id="3-tài-liệu-tham-khảo">3. Tài liệu tham khảo</h1>

<ol>
  <li><a href="https://medium.com/@joealato/attention-in-nlp-734c6fa9d983">Attention in NLP - Kate Loginova
</a></li>
  <li><a href="https://machinelearningmastery.com/timedistributed-layer-for-long-short-term-memory-networks-in-python/">How to Use the TimeDistributed Layer in Keras - machinelearningmastery</a></li>
  <li><a href="https://medium.com/smileinnovation/how-to-work-with-time-distributed-data-in-a-neural-network-b8b39aa4ce00">How to work with Time Distributed data in a neural network - Patrice Ferlet</a></li>
  <li><a href="https://towardsdatascience.com/backpropagation-and-batch-normalization-in-feedforward-neural-networks-explained-901fd6e5393e">Batch Normalization Tensorflow Keras Example - Cory Maklin
</a></li>
  <li>
    <p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/TimeDistributed">Time Distributed Layer - tensorflow 2.0</a></p>
  </li>
  <li>
    <p><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/BatchNormalization">Batch Normalization - tensorflow 2.0</a></p>
  </li>
  <li><a href="https://www.tensorflow.org/api_docs/python/tf/keras/layers/Attention">Attention Layer - tensorflow 2.0</a></li>
</ol>

<script data-ad-client="ca-pub-4263248182804679" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>

<button onclick="topFunction()" id="myBtn" title="Go to top">Top</button>

<script src="/js/toc.js"></script>
<script src="/js/btnTop.js"></script>
<script type="text/javascript">
$(document).ready(function() {
    $('#toc').toc();
});
</script>
				</div>
			</div>
			<div class="col-md-2 hidden-xs hidden-sm">
				<a  href="/">
					<img width="100%" style="padding-bottom: 3mm;" src="/assets/images/logo.jpg" /> </a>
				<br>
				<nav>
					<div class="header">Khanh's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/TowardDataScience">phamdinhkhanh blog</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/3235479620010379/">phamdinhkhanh AICode forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://kaggle.com/phamdinhkhanh">phamdinhkhanh kaggle</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://rpubs.com/phamdinhkhanh">phamdinhkhanh rpub</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://github.com/phamdinhkhanh">phamdinhkhanh github</a></li>
					<br>
					<div class="header">other's site</div>
					<li><a style="text-align: left; color: #074B80"  href="https://www.facebook.com/groups/machinelearningcoban/">machine learning cơ bản facebook</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://forum.machinelearningcoban.com/">machine learning cơ bản forum</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://machinelearningmastery.com">machine learning mastery</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://viblo.asia">viblosia</a></li>
					<br>
					<div class="header">Khóa học</div>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs109/">Xác suất thống kê(Probability): CS109</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs246/">Bigdata: CS246</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://cs231n.stanford.edu/">Computer vision cơ bản: CS231N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224n/">Natural Language Processing: CS224N</a></li>
					<li><a style="text-align: left; color: #074B80"  href="http://web.stanford.edu/class/cs224w/">Khoá phân tích mạng lưới (analysis of network): CS224W</a></li>
					<li><a style="text-align: left; color: #074B80"  href="https://web.stanford.edu/class/cs20si/">Khóa học Tensorflow: CS20SI</a></li>
				</nav>
			</div>
		</div>
	</div>
	
</body>
</html>
